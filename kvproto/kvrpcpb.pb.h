// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kvrpcpb.proto

#ifndef PROTOBUF_INCLUDED_kvrpcpb_2eproto
#define PROTOBUF_INCLUDED_kvrpcpb_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
#include "errorpb.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_kvrpcpb_2eproto 

namespace protobuf_kvrpcpb_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[64];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_kvrpcpb_2eproto
namespace kvrpcpb {
class BatchGetRequest;
class BatchGetRequestDefaultTypeInternal;
extern BatchGetRequestDefaultTypeInternal _BatchGetRequest_default_instance_;
class BatchGetResponse;
class BatchGetResponseDefaultTypeInternal;
extern BatchGetResponseDefaultTypeInternal _BatchGetResponse_default_instance_;
class BatchRollbackRequest;
class BatchRollbackRequestDefaultTypeInternal;
extern BatchRollbackRequestDefaultTypeInternal _BatchRollbackRequest_default_instance_;
class BatchRollbackResponse;
class BatchRollbackResponseDefaultTypeInternal;
extern BatchRollbackResponseDefaultTypeInternal _BatchRollbackResponse_default_instance_;
class CleanupRequest;
class CleanupRequestDefaultTypeInternal;
extern CleanupRequestDefaultTypeInternal _CleanupRequest_default_instance_;
class CleanupResponse;
class CleanupResponseDefaultTypeInternal;
extern CleanupResponseDefaultTypeInternal _CleanupResponse_default_instance_;
class CommitRequest;
class CommitRequestDefaultTypeInternal;
extern CommitRequestDefaultTypeInternal _CommitRequest_default_instance_;
class CommitResponse;
class CommitResponseDefaultTypeInternal;
extern CommitResponseDefaultTypeInternal _CommitResponse_default_instance_;
class Context;
class ContextDefaultTypeInternal;
extern ContextDefaultTypeInternal _Context_default_instance_;
class DeleteRangeRequest;
class DeleteRangeRequestDefaultTypeInternal;
extern DeleteRangeRequestDefaultTypeInternal _DeleteRangeRequest_default_instance_;
class DeleteRangeResponse;
class DeleteRangeResponseDefaultTypeInternal;
extern DeleteRangeResponseDefaultTypeInternal _DeleteRangeResponse_default_instance_;
class ExecDetails;
class ExecDetailsDefaultTypeInternal;
extern ExecDetailsDefaultTypeInternal _ExecDetails_default_instance_;
class GCRequest;
class GCRequestDefaultTypeInternal;
extern GCRequestDefaultTypeInternal _GCRequest_default_instance_;
class GCResponse;
class GCResponseDefaultTypeInternal;
extern GCResponseDefaultTypeInternal _GCResponse_default_instance_;
class GetRequest;
class GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
class GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class HandleTime;
class HandleTimeDefaultTypeInternal;
extern HandleTimeDefaultTypeInternal _HandleTime_default_instance_;
class ImportRequest;
class ImportRequestDefaultTypeInternal;
extern ImportRequestDefaultTypeInternal _ImportRequest_default_instance_;
class ImportResponse;
class ImportResponseDefaultTypeInternal;
extern ImportResponseDefaultTypeInternal _ImportResponse_default_instance_;
class KeyError;
class KeyErrorDefaultTypeInternal;
extern KeyErrorDefaultTypeInternal _KeyError_default_instance_;
class KeyRange;
class KeyRangeDefaultTypeInternal;
extern KeyRangeDefaultTypeInternal _KeyRange_default_instance_;
class KvPair;
class KvPairDefaultTypeInternal;
extern KvPairDefaultTypeInternal _KvPair_default_instance_;
class LockInfo;
class LockInfoDefaultTypeInternal;
extern LockInfoDefaultTypeInternal _LockInfo_default_instance_;
class Mutation;
class MutationDefaultTypeInternal;
extern MutationDefaultTypeInternal _Mutation_default_instance_;
class MvccGetByKeyRequest;
class MvccGetByKeyRequestDefaultTypeInternal;
extern MvccGetByKeyRequestDefaultTypeInternal _MvccGetByKeyRequest_default_instance_;
class MvccGetByKeyResponse;
class MvccGetByKeyResponseDefaultTypeInternal;
extern MvccGetByKeyResponseDefaultTypeInternal _MvccGetByKeyResponse_default_instance_;
class MvccGetByStartTsRequest;
class MvccGetByStartTsRequestDefaultTypeInternal;
extern MvccGetByStartTsRequestDefaultTypeInternal _MvccGetByStartTsRequest_default_instance_;
class MvccGetByStartTsResponse;
class MvccGetByStartTsResponseDefaultTypeInternal;
extern MvccGetByStartTsResponseDefaultTypeInternal _MvccGetByStartTsResponse_default_instance_;
class MvccInfo;
class MvccInfoDefaultTypeInternal;
extern MvccInfoDefaultTypeInternal _MvccInfo_default_instance_;
class MvccLock;
class MvccLockDefaultTypeInternal;
extern MvccLockDefaultTypeInternal _MvccLock_default_instance_;
class MvccValue;
class MvccValueDefaultTypeInternal;
extern MvccValueDefaultTypeInternal _MvccValue_default_instance_;
class MvccWrite;
class MvccWriteDefaultTypeInternal;
extern MvccWriteDefaultTypeInternal _MvccWrite_default_instance_;
class PrewriteRequest;
class PrewriteRequestDefaultTypeInternal;
extern PrewriteRequestDefaultTypeInternal _PrewriteRequest_default_instance_;
class PrewriteResponse;
class PrewriteResponseDefaultTypeInternal;
extern PrewriteResponseDefaultTypeInternal _PrewriteResponse_default_instance_;
class RawBatchDeleteRequest;
class RawBatchDeleteRequestDefaultTypeInternal;
extern RawBatchDeleteRequestDefaultTypeInternal _RawBatchDeleteRequest_default_instance_;
class RawBatchDeleteResponse;
class RawBatchDeleteResponseDefaultTypeInternal;
extern RawBatchDeleteResponseDefaultTypeInternal _RawBatchDeleteResponse_default_instance_;
class RawBatchGetRequest;
class RawBatchGetRequestDefaultTypeInternal;
extern RawBatchGetRequestDefaultTypeInternal _RawBatchGetRequest_default_instance_;
class RawBatchGetResponse;
class RawBatchGetResponseDefaultTypeInternal;
extern RawBatchGetResponseDefaultTypeInternal _RawBatchGetResponse_default_instance_;
class RawBatchPutRequest;
class RawBatchPutRequestDefaultTypeInternal;
extern RawBatchPutRequestDefaultTypeInternal _RawBatchPutRequest_default_instance_;
class RawBatchPutResponse;
class RawBatchPutResponseDefaultTypeInternal;
extern RawBatchPutResponseDefaultTypeInternal _RawBatchPutResponse_default_instance_;
class RawBatchScanRequest;
class RawBatchScanRequestDefaultTypeInternal;
extern RawBatchScanRequestDefaultTypeInternal _RawBatchScanRequest_default_instance_;
class RawBatchScanResponse;
class RawBatchScanResponseDefaultTypeInternal;
extern RawBatchScanResponseDefaultTypeInternal _RawBatchScanResponse_default_instance_;
class RawDeleteRangeRequest;
class RawDeleteRangeRequestDefaultTypeInternal;
extern RawDeleteRangeRequestDefaultTypeInternal _RawDeleteRangeRequest_default_instance_;
class RawDeleteRangeResponse;
class RawDeleteRangeResponseDefaultTypeInternal;
extern RawDeleteRangeResponseDefaultTypeInternal _RawDeleteRangeResponse_default_instance_;
class RawDeleteRequest;
class RawDeleteRequestDefaultTypeInternal;
extern RawDeleteRequestDefaultTypeInternal _RawDeleteRequest_default_instance_;
class RawDeleteResponse;
class RawDeleteResponseDefaultTypeInternal;
extern RawDeleteResponseDefaultTypeInternal _RawDeleteResponse_default_instance_;
class RawGetRequest;
class RawGetRequestDefaultTypeInternal;
extern RawGetRequestDefaultTypeInternal _RawGetRequest_default_instance_;
class RawGetResponse;
class RawGetResponseDefaultTypeInternal;
extern RawGetResponseDefaultTypeInternal _RawGetResponse_default_instance_;
class RawPutRequest;
class RawPutRequestDefaultTypeInternal;
extern RawPutRequestDefaultTypeInternal _RawPutRequest_default_instance_;
class RawPutResponse;
class RawPutResponseDefaultTypeInternal;
extern RawPutResponseDefaultTypeInternal _RawPutResponse_default_instance_;
class RawScanRequest;
class RawScanRequestDefaultTypeInternal;
extern RawScanRequestDefaultTypeInternal _RawScanRequest_default_instance_;
class RawScanResponse;
class RawScanResponseDefaultTypeInternal;
extern RawScanResponseDefaultTypeInternal _RawScanResponse_default_instance_;
class ResolveLockRequest;
class ResolveLockRequestDefaultTypeInternal;
extern ResolveLockRequestDefaultTypeInternal _ResolveLockRequest_default_instance_;
class ResolveLockResponse;
class ResolveLockResponseDefaultTypeInternal;
extern ResolveLockResponseDefaultTypeInternal _ResolveLockResponse_default_instance_;
class ScanDetail;
class ScanDetailDefaultTypeInternal;
extern ScanDetailDefaultTypeInternal _ScanDetail_default_instance_;
class ScanInfo;
class ScanInfoDefaultTypeInternal;
extern ScanInfoDefaultTypeInternal _ScanInfo_default_instance_;
class ScanLockRequest;
class ScanLockRequestDefaultTypeInternal;
extern ScanLockRequestDefaultTypeInternal _ScanLockRequest_default_instance_;
class ScanLockResponse;
class ScanLockResponseDefaultTypeInternal;
extern ScanLockResponseDefaultTypeInternal _ScanLockResponse_default_instance_;
class ScanRequest;
class ScanRequestDefaultTypeInternal;
extern ScanRequestDefaultTypeInternal _ScanRequest_default_instance_;
class ScanResponse;
class ScanResponseDefaultTypeInternal;
extern ScanResponseDefaultTypeInternal _ScanResponse_default_instance_;
class SplitRegionRequest;
class SplitRegionRequestDefaultTypeInternal;
extern SplitRegionRequestDefaultTypeInternal _SplitRegionRequest_default_instance_;
class SplitRegionResponse;
class SplitRegionResponseDefaultTypeInternal;
extern SplitRegionResponseDefaultTypeInternal _SplitRegionResponse_default_instance_;
class TxnInfo;
class TxnInfoDefaultTypeInternal;
extern TxnInfoDefaultTypeInternal _TxnInfo_default_instance_;
class WriteConflict;
class WriteConflictDefaultTypeInternal;
extern WriteConflictDefaultTypeInternal _WriteConflict_default_instance_;
}  // namespace kvrpcpb
namespace google {
namespace protobuf {
template<> ::kvrpcpb::BatchGetRequest* Arena::CreateMaybeMessage<::kvrpcpb::BatchGetRequest>(Arena*);
template<> ::kvrpcpb::BatchGetResponse* Arena::CreateMaybeMessage<::kvrpcpb::BatchGetResponse>(Arena*);
template<> ::kvrpcpb::BatchRollbackRequest* Arena::CreateMaybeMessage<::kvrpcpb::BatchRollbackRequest>(Arena*);
template<> ::kvrpcpb::BatchRollbackResponse* Arena::CreateMaybeMessage<::kvrpcpb::BatchRollbackResponse>(Arena*);
template<> ::kvrpcpb::CleanupRequest* Arena::CreateMaybeMessage<::kvrpcpb::CleanupRequest>(Arena*);
template<> ::kvrpcpb::CleanupResponse* Arena::CreateMaybeMessage<::kvrpcpb::CleanupResponse>(Arena*);
template<> ::kvrpcpb::CommitRequest* Arena::CreateMaybeMessage<::kvrpcpb::CommitRequest>(Arena*);
template<> ::kvrpcpb::CommitResponse* Arena::CreateMaybeMessage<::kvrpcpb::CommitResponse>(Arena*);
template<> ::kvrpcpb::Context* Arena::CreateMaybeMessage<::kvrpcpb::Context>(Arena*);
template<> ::kvrpcpb::DeleteRangeRequest* Arena::CreateMaybeMessage<::kvrpcpb::DeleteRangeRequest>(Arena*);
template<> ::kvrpcpb::DeleteRangeResponse* Arena::CreateMaybeMessage<::kvrpcpb::DeleteRangeResponse>(Arena*);
template<> ::kvrpcpb::ExecDetails* Arena::CreateMaybeMessage<::kvrpcpb::ExecDetails>(Arena*);
template<> ::kvrpcpb::GCRequest* Arena::CreateMaybeMessage<::kvrpcpb::GCRequest>(Arena*);
template<> ::kvrpcpb::GCResponse* Arena::CreateMaybeMessage<::kvrpcpb::GCResponse>(Arena*);
template<> ::kvrpcpb::GetRequest* Arena::CreateMaybeMessage<::kvrpcpb::GetRequest>(Arena*);
template<> ::kvrpcpb::GetResponse* Arena::CreateMaybeMessage<::kvrpcpb::GetResponse>(Arena*);
template<> ::kvrpcpb::HandleTime* Arena::CreateMaybeMessage<::kvrpcpb::HandleTime>(Arena*);
template<> ::kvrpcpb::ImportRequest* Arena::CreateMaybeMessage<::kvrpcpb::ImportRequest>(Arena*);
template<> ::kvrpcpb::ImportResponse* Arena::CreateMaybeMessage<::kvrpcpb::ImportResponse>(Arena*);
template<> ::kvrpcpb::KeyError* Arena::CreateMaybeMessage<::kvrpcpb::KeyError>(Arena*);
template<> ::kvrpcpb::KeyRange* Arena::CreateMaybeMessage<::kvrpcpb::KeyRange>(Arena*);
template<> ::kvrpcpb::KvPair* Arena::CreateMaybeMessage<::kvrpcpb::KvPair>(Arena*);
template<> ::kvrpcpb::LockInfo* Arena::CreateMaybeMessage<::kvrpcpb::LockInfo>(Arena*);
template<> ::kvrpcpb::Mutation* Arena::CreateMaybeMessage<::kvrpcpb::Mutation>(Arena*);
template<> ::kvrpcpb::MvccGetByKeyRequest* Arena::CreateMaybeMessage<::kvrpcpb::MvccGetByKeyRequest>(Arena*);
template<> ::kvrpcpb::MvccGetByKeyResponse* Arena::CreateMaybeMessage<::kvrpcpb::MvccGetByKeyResponse>(Arena*);
template<> ::kvrpcpb::MvccGetByStartTsRequest* Arena::CreateMaybeMessage<::kvrpcpb::MvccGetByStartTsRequest>(Arena*);
template<> ::kvrpcpb::MvccGetByStartTsResponse* Arena::CreateMaybeMessage<::kvrpcpb::MvccGetByStartTsResponse>(Arena*);
template<> ::kvrpcpb::MvccInfo* Arena::CreateMaybeMessage<::kvrpcpb::MvccInfo>(Arena*);
template<> ::kvrpcpb::MvccLock* Arena::CreateMaybeMessage<::kvrpcpb::MvccLock>(Arena*);
template<> ::kvrpcpb::MvccValue* Arena::CreateMaybeMessage<::kvrpcpb::MvccValue>(Arena*);
template<> ::kvrpcpb::MvccWrite* Arena::CreateMaybeMessage<::kvrpcpb::MvccWrite>(Arena*);
template<> ::kvrpcpb::PrewriteRequest* Arena::CreateMaybeMessage<::kvrpcpb::PrewriteRequest>(Arena*);
template<> ::kvrpcpb::PrewriteResponse* Arena::CreateMaybeMessage<::kvrpcpb::PrewriteResponse>(Arena*);
template<> ::kvrpcpb::RawBatchDeleteRequest* Arena::CreateMaybeMessage<::kvrpcpb::RawBatchDeleteRequest>(Arena*);
template<> ::kvrpcpb::RawBatchDeleteResponse* Arena::CreateMaybeMessage<::kvrpcpb::RawBatchDeleteResponse>(Arena*);
template<> ::kvrpcpb::RawBatchGetRequest* Arena::CreateMaybeMessage<::kvrpcpb::RawBatchGetRequest>(Arena*);
template<> ::kvrpcpb::RawBatchGetResponse* Arena::CreateMaybeMessage<::kvrpcpb::RawBatchGetResponse>(Arena*);
template<> ::kvrpcpb::RawBatchPutRequest* Arena::CreateMaybeMessage<::kvrpcpb::RawBatchPutRequest>(Arena*);
template<> ::kvrpcpb::RawBatchPutResponse* Arena::CreateMaybeMessage<::kvrpcpb::RawBatchPutResponse>(Arena*);
template<> ::kvrpcpb::RawBatchScanRequest* Arena::CreateMaybeMessage<::kvrpcpb::RawBatchScanRequest>(Arena*);
template<> ::kvrpcpb::RawBatchScanResponse* Arena::CreateMaybeMessage<::kvrpcpb::RawBatchScanResponse>(Arena*);
template<> ::kvrpcpb::RawDeleteRangeRequest* Arena::CreateMaybeMessage<::kvrpcpb::RawDeleteRangeRequest>(Arena*);
template<> ::kvrpcpb::RawDeleteRangeResponse* Arena::CreateMaybeMessage<::kvrpcpb::RawDeleteRangeResponse>(Arena*);
template<> ::kvrpcpb::RawDeleteRequest* Arena::CreateMaybeMessage<::kvrpcpb::RawDeleteRequest>(Arena*);
template<> ::kvrpcpb::RawDeleteResponse* Arena::CreateMaybeMessage<::kvrpcpb::RawDeleteResponse>(Arena*);
template<> ::kvrpcpb::RawGetRequest* Arena::CreateMaybeMessage<::kvrpcpb::RawGetRequest>(Arena*);
template<> ::kvrpcpb::RawGetResponse* Arena::CreateMaybeMessage<::kvrpcpb::RawGetResponse>(Arena*);
template<> ::kvrpcpb::RawPutRequest* Arena::CreateMaybeMessage<::kvrpcpb::RawPutRequest>(Arena*);
template<> ::kvrpcpb::RawPutResponse* Arena::CreateMaybeMessage<::kvrpcpb::RawPutResponse>(Arena*);
template<> ::kvrpcpb::RawScanRequest* Arena::CreateMaybeMessage<::kvrpcpb::RawScanRequest>(Arena*);
template<> ::kvrpcpb::RawScanResponse* Arena::CreateMaybeMessage<::kvrpcpb::RawScanResponse>(Arena*);
template<> ::kvrpcpb::ResolveLockRequest* Arena::CreateMaybeMessage<::kvrpcpb::ResolveLockRequest>(Arena*);
template<> ::kvrpcpb::ResolveLockResponse* Arena::CreateMaybeMessage<::kvrpcpb::ResolveLockResponse>(Arena*);
template<> ::kvrpcpb::ScanDetail* Arena::CreateMaybeMessage<::kvrpcpb::ScanDetail>(Arena*);
template<> ::kvrpcpb::ScanInfo* Arena::CreateMaybeMessage<::kvrpcpb::ScanInfo>(Arena*);
template<> ::kvrpcpb::ScanLockRequest* Arena::CreateMaybeMessage<::kvrpcpb::ScanLockRequest>(Arena*);
template<> ::kvrpcpb::ScanLockResponse* Arena::CreateMaybeMessage<::kvrpcpb::ScanLockResponse>(Arena*);
template<> ::kvrpcpb::ScanRequest* Arena::CreateMaybeMessage<::kvrpcpb::ScanRequest>(Arena*);
template<> ::kvrpcpb::ScanResponse* Arena::CreateMaybeMessage<::kvrpcpb::ScanResponse>(Arena*);
template<> ::kvrpcpb::SplitRegionRequest* Arena::CreateMaybeMessage<::kvrpcpb::SplitRegionRequest>(Arena*);
template<> ::kvrpcpb::SplitRegionResponse* Arena::CreateMaybeMessage<::kvrpcpb::SplitRegionResponse>(Arena*);
template<> ::kvrpcpb::TxnInfo* Arena::CreateMaybeMessage<::kvrpcpb::TxnInfo>(Arena*);
template<> ::kvrpcpb::WriteConflict* Arena::CreateMaybeMessage<::kvrpcpb::WriteConflict>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace kvrpcpb {

enum CommandPri {
  Normal = 0,
  Low = 1,
  High = 2,
  CommandPri_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CommandPri_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CommandPri_IsValid(int value);
const CommandPri CommandPri_MIN = Normal;
const CommandPri CommandPri_MAX = High;
const int CommandPri_ARRAYSIZE = CommandPri_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommandPri_descriptor();
inline const ::std::string& CommandPri_Name(CommandPri value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommandPri_descriptor(), value);
}
inline bool CommandPri_Parse(
    const ::std::string& name, CommandPri* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommandPri>(
    CommandPri_descriptor(), name, value);
}
enum IsolationLevel {
  SI = 0,
  RC = 1,
  IsolationLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  IsolationLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool IsolationLevel_IsValid(int value);
const IsolationLevel IsolationLevel_MIN = SI;
const IsolationLevel IsolationLevel_MAX = RC;
const int IsolationLevel_ARRAYSIZE = IsolationLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* IsolationLevel_descriptor();
inline const ::std::string& IsolationLevel_Name(IsolationLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    IsolationLevel_descriptor(), value);
}
inline bool IsolationLevel_Parse(
    const ::std::string& name, IsolationLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IsolationLevel>(
    IsolationLevel_descriptor(), name, value);
}
enum Op {
  Put = 0,
  Del = 1,
  Lock = 2,
  Rollback = 3,
  Op_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Op_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Op_IsValid(int value);
const Op Op_MIN = Put;
const Op Op_MAX = Rollback;
const int Op_ARRAYSIZE = Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* Op_descriptor();
inline const ::std::string& Op_Name(Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    Op_descriptor(), value);
}
inline bool Op_Parse(
    const ::std::string& name, Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Op>(
    Op_descriptor(), name, value);
}
// ===================================================================

class LockInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.LockInfo) */ {
 public:
  LockInfo();
  virtual ~LockInfo();

  LockInfo(const LockInfo& from);

  inline LockInfo& operator=(const LockInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LockInfo(LockInfo&& from) noexcept
    : LockInfo() {
    *this = ::std::move(from);
  }

  inline LockInfo& operator=(LockInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LockInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockInfo* internal_default_instance() {
    return reinterpret_cast<const LockInfo*>(
               &_LockInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LockInfo* other);
  friend void swap(LockInfo& a, LockInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LockInfo* New() const final {
    return CreateMaybeMessage<LockInfo>(NULL);
  }

  LockInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LockInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LockInfo& from);
  void MergeFrom(const LockInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes primary_lock = 1;
  void clear_primary_lock();
  static const int kPrimaryLockFieldNumber = 1;
  const ::std::string& primary_lock() const;
  void set_primary_lock(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_lock(::std::string&& value);
  #endif
  void set_primary_lock(const char* value);
  void set_primary_lock(const void* value, size_t size);
  ::std::string* mutable_primary_lock();
  ::std::string* release_primary_lock();
  void set_allocated_primary_lock(::std::string* primary_lock);

  // bytes key = 3;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // uint64 lock_version = 2;
  void clear_lock_version();
  static const int kLockVersionFieldNumber = 2;
  ::google::protobuf::uint64 lock_version() const;
  void set_lock_version(::google::protobuf::uint64 value);

  // uint64 lock_ttl = 4;
  void clear_lock_ttl();
  static const int kLockTtlFieldNumber = 4;
  ::google::protobuf::uint64 lock_ttl() const;
  void set_lock_ttl(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr primary_lock_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::uint64 lock_version_;
  ::google::protobuf::uint64 lock_ttl_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KeyError) */ {
 public:
  KeyError();
  virtual ~KeyError();

  KeyError(const KeyError& from);

  inline KeyError& operator=(const KeyError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyError(KeyError&& from) noexcept
    : KeyError() {
    *this = ::std::move(from);
  }

  inline KeyError& operator=(KeyError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyError* internal_default_instance() {
    return reinterpret_cast<const KeyError*>(
               &_KeyError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(KeyError* other);
  friend void swap(KeyError& a, KeyError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyError* New() const final {
    return CreateMaybeMessage<KeyError>(NULL);
  }

  KeyError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyError& from);
  void MergeFrom(const KeyError& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string retryable = 2;
  void clear_retryable();
  static const int kRetryableFieldNumber = 2;
  const ::std::string& retryable() const;
  void set_retryable(const ::std::string& value);
  #if LANG_CXX11
  void set_retryable(::std::string&& value);
  #endif
  void set_retryable(const char* value);
  void set_retryable(const char* value, size_t size);
  ::std::string* mutable_retryable();
  ::std::string* release_retryable();
  void set_allocated_retryable(::std::string* retryable);

  // string abort = 3;
  void clear_abort();
  static const int kAbortFieldNumber = 3;
  const ::std::string& abort() const;
  void set_abort(const ::std::string& value);
  #if LANG_CXX11
  void set_abort(::std::string&& value);
  #endif
  void set_abort(const char* value);
  void set_abort(const char* value, size_t size);
  ::std::string* mutable_abort();
  ::std::string* release_abort();
  void set_allocated_abort(::std::string* abort);

  // .kvrpcpb.LockInfo locked = 1;
  bool has_locked() const;
  void clear_locked();
  static const int kLockedFieldNumber = 1;
  private:
  const ::kvrpcpb::LockInfo& _internal_locked() const;
  public:
  const ::kvrpcpb::LockInfo& locked() const;
  ::kvrpcpb::LockInfo* release_locked();
  ::kvrpcpb::LockInfo* mutable_locked();
  void set_allocated_locked(::kvrpcpb::LockInfo* locked);

  // .kvrpcpb.WriteConflict conflict = 4;
  bool has_conflict() const;
  void clear_conflict();
  static const int kConflictFieldNumber = 4;
  private:
  const ::kvrpcpb::WriteConflict& _internal_conflict() const;
  public:
  const ::kvrpcpb::WriteConflict& conflict() const;
  ::kvrpcpb::WriteConflict* release_conflict();
  ::kvrpcpb::WriteConflict* mutable_conflict();
  void set_allocated_conflict(::kvrpcpb::WriteConflict* conflict);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KeyError)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr retryable_;
  ::google::protobuf::internal::ArenaStringPtr abort_;
  ::kvrpcpb::LockInfo* locked_;
  ::kvrpcpb::WriteConflict* conflict_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteConflict : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.WriteConflict) */ {
 public:
  WriteConflict();
  virtual ~WriteConflict();

  WriteConflict(const WriteConflict& from);

  inline WriteConflict& operator=(const WriteConflict& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteConflict(WriteConflict&& from) noexcept
    : WriteConflict() {
    *this = ::std::move(from);
  }

  inline WriteConflict& operator=(WriteConflict&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteConflict& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteConflict* internal_default_instance() {
    return reinterpret_cast<const WriteConflict*>(
               &_WriteConflict_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(WriteConflict* other);
  friend void swap(WriteConflict& a, WriteConflict& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteConflict* New() const final {
    return CreateMaybeMessage<WriteConflict>(NULL);
  }

  WriteConflict* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteConflict>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteConflict& from);
  void MergeFrom(const WriteConflict& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteConflict* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 3;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes primary = 4;
  void clear_primary();
  static const int kPrimaryFieldNumber = 4;
  const ::std::string& primary() const;
  void set_primary(const ::std::string& value);
  #if LANG_CXX11
  void set_primary(::std::string&& value);
  #endif
  void set_primary(const char* value);
  void set_primary(const void* value, size_t size);
  ::std::string* mutable_primary();
  ::std::string* release_primary();
  void set_allocated_primary(::std::string* primary);

  // uint64 start_ts = 1;
  void clear_start_ts();
  static const int kStartTsFieldNumber = 1;
  ::google::protobuf::uint64 start_ts() const;
  void set_start_ts(::google::protobuf::uint64 value);

  // uint64 conflict_ts = 2;
  void clear_conflict_ts();
  static const int kConflictTsFieldNumber = 2;
  ::google::protobuf::uint64 conflict_ts() const;
  void set_conflict_ts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.WriteConflict)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr primary_;
  ::google::protobuf::uint64 start_ts_;
  ::google::protobuf::uint64 conflict_ts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Context : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Context) */ {
 public:
  Context();
  virtual ~Context();

  Context(const Context& from);

  inline Context& operator=(const Context& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Context(Context&& from) noexcept
    : Context() {
    *this = ::std::move(from);
  }

  inline Context& operator=(Context&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Context& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Context* internal_default_instance() {
    return reinterpret_cast<const Context*>(
               &_Context_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Context* other);
  friend void swap(Context& a, Context& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Context* New() const final {
    return CreateMaybeMessage<Context>(NULL);
  }

  Context* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Context>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Context& from);
  void MergeFrom(const Context& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Context* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .metapb.RegionEpoch region_epoch = 2;
  bool has_region_epoch() const;
  void clear_region_epoch();
  static const int kRegionEpochFieldNumber = 2;
  private:
  const ::metapb::RegionEpoch& _internal_region_epoch() const;
  public:
  const ::metapb::RegionEpoch& region_epoch() const;
  ::metapb::RegionEpoch* release_region_epoch();
  ::metapb::RegionEpoch* mutable_region_epoch();
  void set_allocated_region_epoch(::metapb::RegionEpoch* region_epoch);

  // .metapb.Peer peer = 3;
  bool has_peer() const;
  void clear_peer();
  static const int kPeerFieldNumber = 3;
  private:
  const ::metapb::Peer& _internal_peer() const;
  public:
  const ::metapb::Peer& peer() const;
  ::metapb::Peer* release_peer();
  ::metapb::Peer* mutable_peer();
  void set_allocated_peer(::metapb::Peer* peer);

  // uint64 region_id = 1;
  void clear_region_id();
  static const int kRegionIdFieldNumber = 1;
  ::google::protobuf::uint64 region_id() const;
  void set_region_id(::google::protobuf::uint64 value);

  // uint64 term = 5;
  void clear_term();
  static const int kTermFieldNumber = 5;
  ::google::protobuf::uint64 term() const;
  void set_term(::google::protobuf::uint64 value);

  // .kvrpcpb.CommandPri priority = 6;
  void clear_priority();
  static const int kPriorityFieldNumber = 6;
  ::kvrpcpb::CommandPri priority() const;
  void set_priority(::kvrpcpb::CommandPri value);

  // .kvrpcpb.IsolationLevel isolation_level = 7;
  void clear_isolation_level();
  static const int kIsolationLevelFieldNumber = 7;
  ::kvrpcpb::IsolationLevel isolation_level() const;
  void set_isolation_level(::kvrpcpb::IsolationLevel value);

  // bool not_fill_cache = 8;
  void clear_not_fill_cache();
  static const int kNotFillCacheFieldNumber = 8;
  bool not_fill_cache() const;
  void set_not_fill_cache(bool value);

  // bool sync_log = 9;
  void clear_sync_log();
  static const int kSyncLogFieldNumber = 9;
  bool sync_log() const;
  void set_sync_log(bool value);

  // bool handle_time = 10;
  void clear_handle_time();
  static const int kHandleTimeFieldNumber = 10;
  bool handle_time() const;
  void set_handle_time(bool value);

  // bool scan_detail = 11;
  void clear_scan_detail();
  static const int kScanDetailFieldNumber = 11;
  bool scan_detail() const;
  void set_scan_detail(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Context)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::metapb::RegionEpoch* region_epoch_;
  ::metapb::Peer* peer_;
  ::google::protobuf::uint64 region_id_;
  ::google::protobuf::uint64 term_;
  int priority_;
  int isolation_level_;
  bool not_fill_cache_;
  bool sync_log_;
  bool handle_time_;
  bool scan_detail_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HandleTime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.HandleTime) */ {
 public:
  HandleTime();
  virtual ~HandleTime();

  HandleTime(const HandleTime& from);

  inline HandleTime& operator=(const HandleTime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HandleTime(HandleTime&& from) noexcept
    : HandleTime() {
    *this = ::std::move(from);
  }

  inline HandleTime& operator=(HandleTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HandleTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HandleTime* internal_default_instance() {
    return reinterpret_cast<const HandleTime*>(
               &_HandleTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(HandleTime* other);
  friend void swap(HandleTime& a, HandleTime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HandleTime* New() const final {
    return CreateMaybeMessage<HandleTime>(NULL);
  }

  HandleTime* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HandleTime>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HandleTime& from);
  void MergeFrom(const HandleTime& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandleTime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 wait_ms = 1;
  void clear_wait_ms();
  static const int kWaitMsFieldNumber = 1;
  ::google::protobuf::int64 wait_ms() const;
  void set_wait_ms(::google::protobuf::int64 value);

  // int64 process_ms = 2;
  void clear_process_ms();
  static const int kProcessMsFieldNumber = 2;
  ::google::protobuf::int64 process_ms() const;
  void set_process_ms(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.HandleTime)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 wait_ms_;
  ::google::protobuf::int64 process_ms_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ScanInfo) */ {
 public:
  ScanInfo();
  virtual ~ScanInfo();

  ScanInfo(const ScanInfo& from);

  inline ScanInfo& operator=(const ScanInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanInfo(ScanInfo&& from) noexcept
    : ScanInfo() {
    *this = ::std::move(from);
  }

  inline ScanInfo& operator=(ScanInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanInfo* internal_default_instance() {
    return reinterpret_cast<const ScanInfo*>(
               &_ScanInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ScanInfo* other);
  friend void swap(ScanInfo& a, ScanInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanInfo* New() const final {
    return CreateMaybeMessage<ScanInfo>(NULL);
  }

  ScanInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScanInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScanInfo& from);
  void MergeFrom(const ScanInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 total = 1;
  void clear_total();
  static const int kTotalFieldNumber = 1;
  ::google::protobuf::int64 total() const;
  void set_total(::google::protobuf::int64 value);

  // int64 processed = 2;
  void clear_processed();
  static const int kProcessedFieldNumber = 2;
  ::google::protobuf::int64 processed() const;
  void set_processed(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ScanInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 total_;
  ::google::protobuf::int64 processed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanDetail : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ScanDetail) */ {
 public:
  ScanDetail();
  virtual ~ScanDetail();

  ScanDetail(const ScanDetail& from);

  inline ScanDetail& operator=(const ScanDetail& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanDetail(ScanDetail&& from) noexcept
    : ScanDetail() {
    *this = ::std::move(from);
  }

  inline ScanDetail& operator=(ScanDetail&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanDetail& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanDetail* internal_default_instance() {
    return reinterpret_cast<const ScanDetail*>(
               &_ScanDetail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ScanDetail* other);
  friend void swap(ScanDetail& a, ScanDetail& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanDetail* New() const final {
    return CreateMaybeMessage<ScanDetail>(NULL);
  }

  ScanDetail* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScanDetail>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScanDetail& from);
  void MergeFrom(const ScanDetail& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanDetail* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.ScanInfo write = 1;
  bool has_write() const;
  void clear_write();
  static const int kWriteFieldNumber = 1;
  private:
  const ::kvrpcpb::ScanInfo& _internal_write() const;
  public:
  const ::kvrpcpb::ScanInfo& write() const;
  ::kvrpcpb::ScanInfo* release_write();
  ::kvrpcpb::ScanInfo* mutable_write();
  void set_allocated_write(::kvrpcpb::ScanInfo* write);

  // .kvrpcpb.ScanInfo lock = 2;
  bool has_lock() const;
  void clear_lock();
  static const int kLockFieldNumber = 2;
  private:
  const ::kvrpcpb::ScanInfo& _internal_lock() const;
  public:
  const ::kvrpcpb::ScanInfo& lock() const;
  ::kvrpcpb::ScanInfo* release_lock();
  ::kvrpcpb::ScanInfo* mutable_lock();
  void set_allocated_lock(::kvrpcpb::ScanInfo* lock);

  // .kvrpcpb.ScanInfo data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  private:
  const ::kvrpcpb::ScanInfo& _internal_data() const;
  public:
  const ::kvrpcpb::ScanInfo& data() const;
  ::kvrpcpb::ScanInfo* release_data();
  ::kvrpcpb::ScanInfo* mutable_data();
  void set_allocated_data(::kvrpcpb::ScanInfo* data);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ScanDetail)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::ScanInfo* write_;
  ::kvrpcpb::ScanInfo* lock_;
  ::kvrpcpb::ScanInfo* data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExecDetails : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ExecDetails) */ {
 public:
  ExecDetails();
  virtual ~ExecDetails();

  ExecDetails(const ExecDetails& from);

  inline ExecDetails& operator=(const ExecDetails& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecDetails(ExecDetails&& from) noexcept
    : ExecDetails() {
    *this = ::std::move(from);
  }

  inline ExecDetails& operator=(ExecDetails&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecDetails& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecDetails* internal_default_instance() {
    return reinterpret_cast<const ExecDetails*>(
               &_ExecDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ExecDetails* other);
  friend void swap(ExecDetails& a, ExecDetails& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecDetails* New() const final {
    return CreateMaybeMessage<ExecDetails>(NULL);
  }

  ExecDetails* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExecDetails>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExecDetails& from);
  void MergeFrom(const ExecDetails& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecDetails* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.HandleTime handle_time = 1;
  bool has_handle_time() const;
  void clear_handle_time();
  static const int kHandleTimeFieldNumber = 1;
  private:
  const ::kvrpcpb::HandleTime& _internal_handle_time() const;
  public:
  const ::kvrpcpb::HandleTime& handle_time() const;
  ::kvrpcpb::HandleTime* release_handle_time();
  ::kvrpcpb::HandleTime* mutable_handle_time();
  void set_allocated_handle_time(::kvrpcpb::HandleTime* handle_time);

  // .kvrpcpb.ScanDetail scan_detail = 2;
  bool has_scan_detail() const;
  void clear_scan_detail();
  static const int kScanDetailFieldNumber = 2;
  private:
  const ::kvrpcpb::ScanDetail& _internal_scan_detail() const;
  public:
  const ::kvrpcpb::ScanDetail& scan_detail() const;
  ::kvrpcpb::ScanDetail* release_scan_detail();
  ::kvrpcpb::ScanDetail* mutable_scan_detail();
  void set_allocated_scan_detail(::kvrpcpb::ScanDetail* scan_detail);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ExecDetails)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::HandleTime* handle_time_;
  ::kvrpcpb::ScanDetail* scan_detail_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.GetRequest) */ {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetRequest* other);
  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRequest* New() const final {
    return CreateMaybeMessage<GetRequest>(NULL);
  }

  GetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.GetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.GetResponse) */ {
 public:
  GetResponse();
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetResponse* other);
  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetResponse* New() const final {
    return CreateMaybeMessage<GetResponse>(NULL);
  }

  GetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // .kvrpcpb.KeyError error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  private:
  const ::kvrpcpb::KeyError& _internal_error() const;
  public:
  const ::kvrpcpb::KeyError& error() const;
  ::kvrpcpb::KeyError* release_error();
  ::kvrpcpb::KeyError* mutable_error();
  void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.GetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::errorpb::Error* region_error_;
  ::kvrpcpb::KeyError* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ScanRequest) */ {
 public:
  ScanRequest();
  virtual ~ScanRequest();

  ScanRequest(const ScanRequest& from);

  inline ScanRequest& operator=(const ScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanRequest(ScanRequest&& from) noexcept
    : ScanRequest() {
    *this = ::std::move(from);
  }

  inline ScanRequest& operator=(ScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanRequest* internal_default_instance() {
    return reinterpret_cast<const ScanRequest*>(
               &_ScanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ScanRequest* other);
  friend void swap(ScanRequest& a, ScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanRequest* New() const final {
    return CreateMaybeMessage<ScanRequest>(NULL);
  }

  ScanRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScanRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScanRequest& from);
  void MergeFrom(const ScanRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start_key = 2;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 2;
  const ::std::string& start_key() const;
  void set_start_key(const ::std::string& value);
  #if LANG_CXX11
  void set_start_key(::std::string&& value);
  #endif
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  ::std::string* mutable_start_key();
  ::std::string* release_start_key();
  void set_allocated_start_key(::std::string* start_key);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 version = 4;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // uint32 limit = 3;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // bool key_only = 5;
  void clear_key_only();
  static const int kKeyOnlyFieldNumber = 5;
  bool key_only() const;
  void set_key_only(bool value);

  // bool reverse = 6;
  void clear_reverse();
  static const int kReverseFieldNumber = 6;
  bool reverse() const;
  void set_reverse(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_key_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 version_;
  ::google::protobuf::uint32 limit_;
  bool key_only_;
  bool reverse_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KvPair) */ {
 public:
  KvPair();
  virtual ~KvPair();

  KvPair(const KvPair& from);

  inline KvPair& operator=(const KvPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvPair(KvPair&& from) noexcept
    : KvPair() {
    *this = ::std::move(from);
  }

  inline KvPair& operator=(KvPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KvPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KvPair* internal_default_instance() {
    return reinterpret_cast<const KvPair*>(
               &_KvPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(KvPair* other);
  friend void swap(KvPair& a, KvPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvPair* New() const final {
    return CreateMaybeMessage<KvPair>(NULL);
  }

  KvPair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KvPair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KvPair& from);
  void MergeFrom(const KvPair& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KvPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .kvrpcpb.KeyError error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::kvrpcpb::KeyError& _internal_error() const;
  public:
  const ::kvrpcpb::KeyError& error() const;
  ::kvrpcpb::KeyError* release_error();
  ::kvrpcpb::KeyError* mutable_error();
  void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvPair)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::kvrpcpb::KeyError* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ScanResponse) */ {
 public:
  ScanResponse();
  virtual ~ScanResponse();

  ScanResponse(const ScanResponse& from);

  inline ScanResponse& operator=(const ScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanResponse(ScanResponse&& from) noexcept
    : ScanResponse() {
    *this = ::std::move(from);
  }

  inline ScanResponse& operator=(ScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanResponse* internal_default_instance() {
    return reinterpret_cast<const ScanResponse*>(
               &_ScanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ScanResponse* other);
  friend void swap(ScanResponse& a, ScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanResponse* New() const final {
    return CreateMaybeMessage<ScanResponse>(NULL);
  }

  ScanResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScanResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScanResponse& from);
  void MergeFrom(const ScanResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KvPair pairs = 2;
  int pairs_size() const;
  void clear_pairs();
  static const int kPairsFieldNumber = 2;
  ::kvrpcpb::KvPair* mutable_pairs(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
      mutable_pairs();
  const ::kvrpcpb::KvPair& pairs(int index) const;
  ::kvrpcpb::KvPair* add_pairs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
      pairs() const;

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair > pairs_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mutation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.Mutation) */ {
 public:
  Mutation();
  virtual ~Mutation();

  Mutation(const Mutation& from);

  inline Mutation& operator=(const Mutation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mutation(Mutation&& from) noexcept
    : Mutation() {
    *this = ::std::move(from);
  }

  inline Mutation& operator=(Mutation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mutation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mutation* internal_default_instance() {
    return reinterpret_cast<const Mutation*>(
               &_Mutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Mutation* other);
  friend void swap(Mutation& a, Mutation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mutation* New() const final {
    return CreateMaybeMessage<Mutation>(NULL);
  }

  Mutation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mutation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mutation& from);
  void MergeFrom(const Mutation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mutation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .kvrpcpb.Op op = 1;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::kvrpcpb::Op op() const;
  void set_op(::kvrpcpb::Op value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Mutation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  int op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PrewriteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.PrewriteRequest) */ {
 public:
  PrewriteRequest();
  virtual ~PrewriteRequest();

  PrewriteRequest(const PrewriteRequest& from);

  inline PrewriteRequest& operator=(const PrewriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PrewriteRequest(PrewriteRequest&& from) noexcept
    : PrewriteRequest() {
    *this = ::std::move(from);
  }

  inline PrewriteRequest& operator=(PrewriteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PrewriteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrewriteRequest* internal_default_instance() {
    return reinterpret_cast<const PrewriteRequest*>(
               &_PrewriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(PrewriteRequest* other);
  friend void swap(PrewriteRequest& a, PrewriteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PrewriteRequest* New() const final {
    return CreateMaybeMessage<PrewriteRequest>(NULL);
  }

  PrewriteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PrewriteRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PrewriteRequest& from);
  void MergeFrom(const PrewriteRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrewriteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.Mutation mutations = 2;
  int mutations_size() const;
  void clear_mutations();
  static const int kMutationsFieldNumber = 2;
  ::kvrpcpb::Mutation* mutable_mutations(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >*
      mutable_mutations();
  const ::kvrpcpb::Mutation& mutations(int index) const;
  ::kvrpcpb::Mutation* add_mutations();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >&
      mutations() const;

  // bytes primary_lock = 3;
  void clear_primary_lock();
  static const int kPrimaryLockFieldNumber = 3;
  const ::std::string& primary_lock() const;
  void set_primary_lock(const ::std::string& value);
  #if LANG_CXX11
  void set_primary_lock(::std::string&& value);
  #endif
  void set_primary_lock(const char* value);
  void set_primary_lock(const void* value, size_t size);
  ::std::string* mutable_primary_lock();
  ::std::string* release_primary_lock();
  void set_allocated_primary_lock(::std::string* primary_lock);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 start_version = 4;
  void clear_start_version();
  static const int kStartVersionFieldNumber = 4;
  ::google::protobuf::uint64 start_version() const;
  void set_start_version(::google::protobuf::uint64 value);

  // uint64 lock_ttl = 5;
  void clear_lock_ttl();
  static const int kLockTtlFieldNumber = 5;
  ::google::protobuf::uint64 lock_ttl() const;
  void set_lock_ttl(::google::protobuf::uint64 value);

  // bool skip_constraint_check = 6;
  void clear_skip_constraint_check();
  static const int kSkipConstraintCheckFieldNumber = 6;
  bool skip_constraint_check() const;
  void set_skip_constraint_check(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.PrewriteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation > mutations_;
  ::google::protobuf::internal::ArenaStringPtr primary_lock_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 start_version_;
  ::google::protobuf::uint64 lock_ttl_;
  bool skip_constraint_check_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PrewriteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.PrewriteResponse) */ {
 public:
  PrewriteResponse();
  virtual ~PrewriteResponse();

  PrewriteResponse(const PrewriteResponse& from);

  inline PrewriteResponse& operator=(const PrewriteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PrewriteResponse(PrewriteResponse&& from) noexcept
    : PrewriteResponse() {
    *this = ::std::move(from);
  }

  inline PrewriteResponse& operator=(PrewriteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PrewriteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrewriteResponse* internal_default_instance() {
    return reinterpret_cast<const PrewriteResponse*>(
               &_PrewriteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(PrewriteResponse* other);
  friend void swap(PrewriteResponse& a, PrewriteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PrewriteResponse* New() const final {
    return CreateMaybeMessage<PrewriteResponse>(NULL);
  }

  PrewriteResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PrewriteResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PrewriteResponse& from);
  void MergeFrom(const PrewriteResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrewriteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KeyError errors = 2;
  int errors_size() const;
  void clear_errors();
  static const int kErrorsFieldNumber = 2;
  ::kvrpcpb::KeyError* mutable_errors(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyError >*
      mutable_errors();
  const ::kvrpcpb::KeyError& errors(int index) const;
  ::kvrpcpb::KeyError* add_errors();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyError >&
      errors() const;

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.PrewriteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyError > errors_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.CommitRequest) */ {
 public:
  CommitRequest();
  virtual ~CommitRequest();

  CommitRequest(const CommitRequest& from);

  inline CommitRequest& operator=(const CommitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommitRequest(CommitRequest&& from) noexcept
    : CommitRequest() {
    *this = ::std::move(from);
  }

  inline CommitRequest& operator=(CommitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommitRequest* internal_default_instance() {
    return reinterpret_cast<const CommitRequest*>(
               &_CommitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CommitRequest* other);
  friend void swap(CommitRequest& a, CommitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommitRequest* New() const final {
    return CreateMaybeMessage<CommitRequest>(NULL);
  }

  CommitRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommitRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommitRequest& from);
  void MergeFrom(const CommitRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 3;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 start_version = 2;
  void clear_start_version();
  static const int kStartVersionFieldNumber = 2;
  ::google::protobuf::uint64 start_version() const;
  void set_start_version(::google::protobuf::uint64 value);

  // uint64 commit_version = 4;
  void clear_commit_version();
  static const int kCommitVersionFieldNumber = 4;
  ::google::protobuf::uint64 commit_version() const;
  void set_commit_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CommitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 start_version_;
  ::google::protobuf::uint64 commit_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CommitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.CommitResponse) */ {
 public:
  CommitResponse();
  virtual ~CommitResponse();

  CommitResponse(const CommitResponse& from);

  inline CommitResponse& operator=(const CommitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CommitResponse(CommitResponse&& from) noexcept
    : CommitResponse() {
    *this = ::std::move(from);
  }

  inline CommitResponse& operator=(CommitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommitResponse* internal_default_instance() {
    return reinterpret_cast<const CommitResponse*>(
               &_CommitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CommitResponse* other);
  friend void swap(CommitResponse& a, CommitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CommitResponse* New() const final {
    return CreateMaybeMessage<CommitResponse>(NULL);
  }

  CommitResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CommitResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CommitResponse& from);
  void MergeFrom(const CommitResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // .kvrpcpb.KeyError error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  private:
  const ::kvrpcpb::KeyError& _internal_error() const;
  public:
  const ::kvrpcpb::KeyError& error() const;
  ::kvrpcpb::KeyError* release_error();
  ::kvrpcpb::KeyError* mutable_error();
  void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CommitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::errorpb::Error* region_error_;
  ::kvrpcpb::KeyError* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImportRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ImportRequest) */ {
 public:
  ImportRequest();
  virtual ~ImportRequest();

  ImportRequest(const ImportRequest& from);

  inline ImportRequest& operator=(const ImportRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImportRequest(ImportRequest&& from) noexcept
    : ImportRequest() {
    *this = ::std::move(from);
  }

  inline ImportRequest& operator=(ImportRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImportRequest* internal_default_instance() {
    return reinterpret_cast<const ImportRequest*>(
               &_ImportRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ImportRequest* other);
  friend void swap(ImportRequest& a, ImportRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImportRequest* New() const final {
    return CreateMaybeMessage<ImportRequest>(NULL);
  }

  ImportRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImportRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImportRequest& from);
  void MergeFrom(const ImportRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.Mutation mutations = 1;
  int mutations_size() const;
  void clear_mutations();
  static const int kMutationsFieldNumber = 1;
  ::kvrpcpb::Mutation* mutable_mutations(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >*
      mutable_mutations();
  const ::kvrpcpb::Mutation& mutations(int index) const;
  ::kvrpcpb::Mutation* add_mutations();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >&
      mutations() const;

  // uint64 commit_version = 2;
  void clear_commit_version();
  static const int kCommitVersionFieldNumber = 2;
  ::google::protobuf::uint64 commit_version() const;
  void set_commit_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ImportRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation > mutations_;
  ::google::protobuf::uint64 commit_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImportResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ImportResponse) */ {
 public:
  ImportResponse();
  virtual ~ImportResponse();

  ImportResponse(const ImportResponse& from);

  inline ImportResponse& operator=(const ImportResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImportResponse(ImportResponse&& from) noexcept
    : ImportResponse() {
    *this = ::std::move(from);
  }

  inline ImportResponse& operator=(ImportResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImportResponse* internal_default_instance() {
    return reinterpret_cast<const ImportResponse*>(
               &_ImportResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ImportResponse* other);
  friend void swap(ImportResponse& a, ImportResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImportResponse* New() const final {
    return CreateMaybeMessage<ImportResponse>(NULL);
  }

  ImportResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImportResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImportResponse& from);
  void MergeFrom(const ImportResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ImportResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchRollbackRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.BatchRollbackRequest) */ {
 public:
  BatchRollbackRequest();
  virtual ~BatchRollbackRequest();

  BatchRollbackRequest(const BatchRollbackRequest& from);

  inline BatchRollbackRequest& operator=(const BatchRollbackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchRollbackRequest(BatchRollbackRequest&& from) noexcept
    : BatchRollbackRequest() {
    *this = ::std::move(from);
  }

  inline BatchRollbackRequest& operator=(BatchRollbackRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchRollbackRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchRollbackRequest* internal_default_instance() {
    return reinterpret_cast<const BatchRollbackRequest*>(
               &_BatchRollbackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(BatchRollbackRequest* other);
  friend void swap(BatchRollbackRequest& a, BatchRollbackRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchRollbackRequest* New() const final {
    return CreateMaybeMessage<BatchRollbackRequest>(NULL);
  }

  BatchRollbackRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BatchRollbackRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BatchRollbackRequest& from);
  void MergeFrom(const BatchRollbackRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchRollbackRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 3;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 3;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 start_version = 2;
  void clear_start_version();
  static const int kStartVersionFieldNumber = 2;
  ::google::protobuf::uint64 start_version() const;
  void set_start_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.BatchRollbackRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 start_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchRollbackResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.BatchRollbackResponse) */ {
 public:
  BatchRollbackResponse();
  virtual ~BatchRollbackResponse();

  BatchRollbackResponse(const BatchRollbackResponse& from);

  inline BatchRollbackResponse& operator=(const BatchRollbackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchRollbackResponse(BatchRollbackResponse&& from) noexcept
    : BatchRollbackResponse() {
    *this = ::std::move(from);
  }

  inline BatchRollbackResponse& operator=(BatchRollbackResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchRollbackResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchRollbackResponse* internal_default_instance() {
    return reinterpret_cast<const BatchRollbackResponse*>(
               &_BatchRollbackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(BatchRollbackResponse* other);
  friend void swap(BatchRollbackResponse& a, BatchRollbackResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchRollbackResponse* New() const final {
    return CreateMaybeMessage<BatchRollbackResponse>(NULL);
  }

  BatchRollbackResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BatchRollbackResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BatchRollbackResponse& from);
  void MergeFrom(const BatchRollbackResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchRollbackResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // .kvrpcpb.KeyError error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  private:
  const ::kvrpcpb::KeyError& _internal_error() const;
  public:
  const ::kvrpcpb::KeyError& error() const;
  ::kvrpcpb::KeyError* release_error();
  ::kvrpcpb::KeyError* mutable_error();
  void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.BatchRollbackResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::errorpb::Error* region_error_;
  ::kvrpcpb::KeyError* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CleanupRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.CleanupRequest) */ {
 public:
  CleanupRequest();
  virtual ~CleanupRequest();

  CleanupRequest(const CleanupRequest& from);

  inline CleanupRequest& operator=(const CleanupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CleanupRequest(CleanupRequest&& from) noexcept
    : CleanupRequest() {
    *this = ::std::move(from);
  }

  inline CleanupRequest& operator=(CleanupRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CleanupRequest* internal_default_instance() {
    return reinterpret_cast<const CleanupRequest*>(
               &_CleanupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(CleanupRequest* other);
  friend void swap(CleanupRequest& a, CleanupRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CleanupRequest* New() const final {
    return CreateMaybeMessage<CleanupRequest>(NULL);
  }

  CleanupRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CleanupRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CleanupRequest& from);
  void MergeFrom(const CleanupRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 start_version = 3;
  void clear_start_version();
  static const int kStartVersionFieldNumber = 3;
  ::google::protobuf::uint64 start_version() const;
  void set_start_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CleanupRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 start_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CleanupResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.CleanupResponse) */ {
 public:
  CleanupResponse();
  virtual ~CleanupResponse();

  CleanupResponse(const CleanupResponse& from);

  inline CleanupResponse& operator=(const CleanupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CleanupResponse(CleanupResponse&& from) noexcept
    : CleanupResponse() {
    *this = ::std::move(from);
  }

  inline CleanupResponse& operator=(CleanupResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanupResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CleanupResponse* internal_default_instance() {
    return reinterpret_cast<const CleanupResponse*>(
               &_CleanupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(CleanupResponse* other);
  friend void swap(CleanupResponse& a, CleanupResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CleanupResponse* New() const final {
    return CreateMaybeMessage<CleanupResponse>(NULL);
  }

  CleanupResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CleanupResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CleanupResponse& from);
  void MergeFrom(const CleanupResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanupResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // .kvrpcpb.KeyError error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  private:
  const ::kvrpcpb::KeyError& _internal_error() const;
  public:
  const ::kvrpcpb::KeyError& error() const;
  ::kvrpcpb::KeyError* release_error();
  ::kvrpcpb::KeyError* mutable_error();
  void set_allocated_error(::kvrpcpb::KeyError* error);

  // uint64 commit_version = 3;
  void clear_commit_version();
  static const int kCommitVersionFieldNumber = 3;
  ::google::protobuf::uint64 commit_version() const;
  void set_commit_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CleanupResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::errorpb::Error* region_error_;
  ::kvrpcpb::KeyError* error_;
  ::google::protobuf::uint64 commit_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.BatchGetRequest) */ {
 public:
  BatchGetRequest();
  virtual ~BatchGetRequest();

  BatchGetRequest(const BatchGetRequest& from);

  inline BatchGetRequest& operator=(const BatchGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchGetRequest(BatchGetRequest&& from) noexcept
    : BatchGetRequest() {
    *this = ::std::move(from);
  }

  inline BatchGetRequest& operator=(BatchGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchGetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchGetRequest* internal_default_instance() {
    return reinterpret_cast<const BatchGetRequest*>(
               &_BatchGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(BatchGetRequest* other);
  friend void swap(BatchGetRequest& a, BatchGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchGetRequest* New() const final {
    return CreateMaybeMessage<BatchGetRequest>(NULL);
  }

  BatchGetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BatchGetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BatchGetRequest& from);
  void MergeFrom(const BatchGetRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 2;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.BatchGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BatchGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.BatchGetResponse) */ {
 public:
  BatchGetResponse();
  virtual ~BatchGetResponse();

  BatchGetResponse(const BatchGetResponse& from);

  inline BatchGetResponse& operator=(const BatchGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BatchGetResponse(BatchGetResponse&& from) noexcept
    : BatchGetResponse() {
    *this = ::std::move(from);
  }

  inline BatchGetResponse& operator=(BatchGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchGetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BatchGetResponse* internal_default_instance() {
    return reinterpret_cast<const BatchGetResponse*>(
               &_BatchGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(BatchGetResponse* other);
  friend void swap(BatchGetResponse& a, BatchGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BatchGetResponse* New() const final {
    return CreateMaybeMessage<BatchGetResponse>(NULL);
  }

  BatchGetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BatchGetResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BatchGetResponse& from);
  void MergeFrom(const BatchGetResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KvPair pairs = 2;
  int pairs_size() const;
  void clear_pairs();
  static const int kPairsFieldNumber = 2;
  ::kvrpcpb::KvPair* mutable_pairs(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
      mutable_pairs();
  const ::kvrpcpb::KvPair& pairs(int index) const;
  ::kvrpcpb::KvPair* add_pairs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
      pairs() const;

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.BatchGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair > pairs_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanLockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ScanLockRequest) */ {
 public:
  ScanLockRequest();
  virtual ~ScanLockRequest();

  ScanLockRequest(const ScanLockRequest& from);

  inline ScanLockRequest& operator=(const ScanLockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanLockRequest(ScanLockRequest&& from) noexcept
    : ScanLockRequest() {
    *this = ::std::move(from);
  }

  inline ScanLockRequest& operator=(ScanLockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanLockRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanLockRequest* internal_default_instance() {
    return reinterpret_cast<const ScanLockRequest*>(
               &_ScanLockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(ScanLockRequest* other);
  friend void swap(ScanLockRequest& a, ScanLockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanLockRequest* New() const final {
    return CreateMaybeMessage<ScanLockRequest>(NULL);
  }

  ScanLockRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScanLockRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScanLockRequest& from);
  void MergeFrom(const ScanLockRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanLockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start_key = 3;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 3;
  const ::std::string& start_key() const;
  void set_start_key(const ::std::string& value);
  #if LANG_CXX11
  void set_start_key(::std::string&& value);
  #endif
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  ::std::string* mutable_start_key();
  ::std::string* release_start_key();
  void set_allocated_start_key(::std::string* start_key);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 max_version = 2;
  void clear_max_version();
  static const int kMaxVersionFieldNumber = 2;
  ::google::protobuf::uint64 max_version() const;
  void set_max_version(::google::protobuf::uint64 value);

  // uint32 limit = 4;
  void clear_limit();
  static const int kLimitFieldNumber = 4;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ScanLockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_key_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 max_version_;
  ::google::protobuf::uint32 limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanLockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ScanLockResponse) */ {
 public:
  ScanLockResponse();
  virtual ~ScanLockResponse();

  ScanLockResponse(const ScanLockResponse& from);

  inline ScanLockResponse& operator=(const ScanLockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanLockResponse(ScanLockResponse&& from) noexcept
    : ScanLockResponse() {
    *this = ::std::move(from);
  }

  inline ScanLockResponse& operator=(ScanLockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanLockResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanLockResponse* internal_default_instance() {
    return reinterpret_cast<const ScanLockResponse*>(
               &_ScanLockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(ScanLockResponse* other);
  friend void swap(ScanLockResponse& a, ScanLockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanLockResponse* New() const final {
    return CreateMaybeMessage<ScanLockResponse>(NULL);
  }

  ScanLockResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ScanLockResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ScanLockResponse& from);
  void MergeFrom(const ScanLockResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanLockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.LockInfo locks = 3;
  int locks_size() const;
  void clear_locks();
  static const int kLocksFieldNumber = 3;
  ::kvrpcpb::LockInfo* mutable_locks(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >*
      mutable_locks();
  const ::kvrpcpb::LockInfo& locks(int index) const;
  ::kvrpcpb::LockInfo* add_locks();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >&
      locks() const;

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // .kvrpcpb.KeyError error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  private:
  const ::kvrpcpb::KeyError& _internal_error() const;
  public:
  const ::kvrpcpb::KeyError& error() const;
  ::kvrpcpb::KeyError* release_error();
  ::kvrpcpb::KeyError* mutable_error();
  void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ScanLockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo > locks_;
  ::errorpb::Error* region_error_;
  ::kvrpcpb::KeyError* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxnInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.TxnInfo) */ {
 public:
  TxnInfo();
  virtual ~TxnInfo();

  TxnInfo(const TxnInfo& from);

  inline TxnInfo& operator=(const TxnInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxnInfo(TxnInfo&& from) noexcept
    : TxnInfo() {
    *this = ::std::move(from);
  }

  inline TxnInfo& operator=(TxnInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxnInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxnInfo* internal_default_instance() {
    return reinterpret_cast<const TxnInfo*>(
               &_TxnInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(TxnInfo* other);
  friend void swap(TxnInfo& a, TxnInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxnInfo* New() const final {
    return CreateMaybeMessage<TxnInfo>(NULL);
  }

  TxnInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxnInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxnInfo& from);
  void MergeFrom(const TxnInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxnInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 txn = 1;
  void clear_txn();
  static const int kTxnFieldNumber = 1;
  ::google::protobuf::uint64 txn() const;
  void set_txn(::google::protobuf::uint64 value);

  // uint64 status = 2;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::google::protobuf::uint64 status() const;
  void set_status(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.TxnInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 txn_;
  ::google::protobuf::uint64 status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolveLockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ResolveLockRequest) */ {
 public:
  ResolveLockRequest();
  virtual ~ResolveLockRequest();

  ResolveLockRequest(const ResolveLockRequest& from);

  inline ResolveLockRequest& operator=(const ResolveLockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolveLockRequest(ResolveLockRequest&& from) noexcept
    : ResolveLockRequest() {
    *this = ::std::move(from);
  }

  inline ResolveLockRequest& operator=(ResolveLockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolveLockRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolveLockRequest* internal_default_instance() {
    return reinterpret_cast<const ResolveLockRequest*>(
               &_ResolveLockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ResolveLockRequest* other);
  friend void swap(ResolveLockRequest& a, ResolveLockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolveLockRequest* New() const final {
    return CreateMaybeMessage<ResolveLockRequest>(NULL);
  }

  ResolveLockRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolveLockRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolveLockRequest& from);
  void MergeFrom(const ResolveLockRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolveLockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.TxnInfo txn_infos = 4;
  int txn_infos_size() const;
  void clear_txn_infos();
  static const int kTxnInfosFieldNumber = 4;
  ::kvrpcpb::TxnInfo* mutable_txn_infos(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::TxnInfo >*
      mutable_txn_infos();
  const ::kvrpcpb::TxnInfo& txn_infos(int index) const;
  ::kvrpcpb::TxnInfo* add_txn_infos();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::TxnInfo >&
      txn_infos() const;

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 start_version = 2;
  void clear_start_version();
  static const int kStartVersionFieldNumber = 2;
  ::google::protobuf::uint64 start_version() const;
  void set_start_version(::google::protobuf::uint64 value);

  // uint64 commit_version = 3;
  void clear_commit_version();
  static const int kCommitVersionFieldNumber = 3;
  ::google::protobuf::uint64 commit_version() const;
  void set_commit_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ResolveLockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::TxnInfo > txn_infos_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 start_version_;
  ::google::protobuf::uint64 commit_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResolveLockResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.ResolveLockResponse) */ {
 public:
  ResolveLockResponse();
  virtual ~ResolveLockResponse();

  ResolveLockResponse(const ResolveLockResponse& from);

  inline ResolveLockResponse& operator=(const ResolveLockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResolveLockResponse(ResolveLockResponse&& from) noexcept
    : ResolveLockResponse() {
    *this = ::std::move(from);
  }

  inline ResolveLockResponse& operator=(ResolveLockResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResolveLockResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResolveLockResponse* internal_default_instance() {
    return reinterpret_cast<const ResolveLockResponse*>(
               &_ResolveLockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(ResolveLockResponse* other);
  friend void swap(ResolveLockResponse& a, ResolveLockResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResolveLockResponse* New() const final {
    return CreateMaybeMessage<ResolveLockResponse>(NULL);
  }

  ResolveLockResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResolveLockResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResolveLockResponse& from);
  void MergeFrom(const ResolveLockResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResolveLockResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // .kvrpcpb.KeyError error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  private:
  const ::kvrpcpb::KeyError& _internal_error() const;
  public:
  const ::kvrpcpb::KeyError& error() const;
  ::kvrpcpb::KeyError* release_error();
  ::kvrpcpb::KeyError* mutable_error();
  void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.ResolveLockResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::errorpb::Error* region_error_;
  ::kvrpcpb::KeyError* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GCRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.GCRequest) */ {
 public:
  GCRequest();
  virtual ~GCRequest();

  GCRequest(const GCRequest& from);

  inline GCRequest& operator=(const GCRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GCRequest(GCRequest&& from) noexcept
    : GCRequest() {
    *this = ::std::move(from);
  }

  inline GCRequest& operator=(GCRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GCRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GCRequest* internal_default_instance() {
    return reinterpret_cast<const GCRequest*>(
               &_GCRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(GCRequest* other);
  friend void swap(GCRequest& a, GCRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GCRequest* New() const final {
    return CreateMaybeMessage<GCRequest>(NULL);
  }

  GCRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GCRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GCRequest& from);
  void MergeFrom(const GCRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GCRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 safe_point = 2;
  void clear_safe_point();
  static const int kSafePointFieldNumber = 2;
  ::google::protobuf::uint64 safe_point() const;
  void set_safe_point(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.GCRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 safe_point_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GCResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.GCResponse) */ {
 public:
  GCResponse();
  virtual ~GCResponse();

  GCResponse(const GCResponse& from);

  inline GCResponse& operator=(const GCResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GCResponse(GCResponse&& from) noexcept
    : GCResponse() {
    *this = ::std::move(from);
  }

  inline GCResponse& operator=(GCResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GCResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GCResponse* internal_default_instance() {
    return reinterpret_cast<const GCResponse*>(
               &_GCResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(GCResponse* other);
  friend void swap(GCResponse& a, GCResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GCResponse* New() const final {
    return CreateMaybeMessage<GCResponse>(NULL);
  }

  GCResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GCResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GCResponse& from);
  void MergeFrom(const GCResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GCResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // .kvrpcpb.KeyError error = 2;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  private:
  const ::kvrpcpb::KeyError& _internal_error() const;
  public:
  const ::kvrpcpb::KeyError& error() const;
  ::kvrpcpb::KeyError* release_error();
  ::kvrpcpb::KeyError* mutable_error();
  void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.GCResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::errorpb::Error* region_error_;
  ::kvrpcpb::KeyError* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawGetRequest) */ {
 public:
  RawGetRequest();
  virtual ~RawGetRequest();

  RawGetRequest(const RawGetRequest& from);

  inline RawGetRequest& operator=(const RawGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawGetRequest(RawGetRequest&& from) noexcept
    : RawGetRequest() {
    *this = ::std::move(from);
  }

  inline RawGetRequest& operator=(RawGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawGetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawGetRequest* internal_default_instance() {
    return reinterpret_cast<const RawGetRequest*>(
               &_RawGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(RawGetRequest* other);
  friend void swap(RawGetRequest& a, RawGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawGetRequest* New() const final {
    return CreateMaybeMessage<RawGetRequest>(NULL);
  }

  RawGetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawGetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawGetRequest& from);
  void MergeFrom(const RawGetRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string cf = 3;
  void clear_cf();
  static const int kCfFieldNumber = 3;
  const ::std::string& cf() const;
  void set_cf(const ::std::string& value);
  #if LANG_CXX11
  void set_cf(::std::string&& value);
  #endif
  void set_cf(const char* value);
  void set_cf(const char* value, size_t size);
  ::std::string* mutable_cf();
  ::std::string* release_cf();
  void set_allocated_cf(::std::string* cf);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr cf_;
  ::kvrpcpb::Context* context_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawGetResponse) */ {
 public:
  RawGetResponse();
  virtual ~RawGetResponse();

  RawGetResponse(const RawGetResponse& from);

  inline RawGetResponse& operator=(const RawGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawGetResponse(RawGetResponse&& from) noexcept
    : RawGetResponse() {
    *this = ::std::move(from);
  }

  inline RawGetResponse& operator=(RawGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawGetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawGetResponse* internal_default_instance() {
    return reinterpret_cast<const RawGetResponse*>(
               &_RawGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(RawGetResponse* other);
  friend void swap(RawGetResponse& a, RawGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawGetResponse* New() const final {
    return CreateMaybeMessage<RawGetResponse>(NULL);
  }

  RawGetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawGetResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawGetResponse& from);
  void MergeFrom(const RawGetResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawPutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawPutRequest) */ {
 public:
  RawPutRequest();
  virtual ~RawPutRequest();

  RawPutRequest(const RawPutRequest& from);

  inline RawPutRequest& operator=(const RawPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawPutRequest(RawPutRequest&& from) noexcept
    : RawPutRequest() {
    *this = ::std::move(from);
  }

  inline RawPutRequest& operator=(RawPutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawPutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawPutRequest* internal_default_instance() {
    return reinterpret_cast<const RawPutRequest*>(
               &_RawPutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(RawPutRequest* other);
  friend void swap(RawPutRequest& a, RawPutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawPutRequest* New() const final {
    return CreateMaybeMessage<RawPutRequest>(NULL);
  }

  RawPutRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawPutRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawPutRequest& from);
  void MergeFrom(const RawPutRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawPutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string cf = 4;
  void clear_cf();
  static const int kCfFieldNumber = 4;
  const ::std::string& cf() const;
  void set_cf(const ::std::string& value);
  #if LANG_CXX11
  void set_cf(::std::string&& value);
  #endif
  void set_cf(const char* value);
  void set_cf(const char* value, size_t size);
  ::std::string* mutable_cf();
  ::std::string* release_cf();
  void set_allocated_cf(::std::string* cf);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawPutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr cf_;
  ::kvrpcpb::Context* context_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawPutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawPutResponse) */ {
 public:
  RawPutResponse();
  virtual ~RawPutResponse();

  RawPutResponse(const RawPutResponse& from);

  inline RawPutResponse& operator=(const RawPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawPutResponse(RawPutResponse&& from) noexcept
    : RawPutResponse() {
    *this = ::std::move(from);
  }

  inline RawPutResponse& operator=(RawPutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawPutResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawPutResponse* internal_default_instance() {
    return reinterpret_cast<const RawPutResponse*>(
               &_RawPutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(RawPutResponse* other);
  friend void swap(RawPutResponse& a, RawPutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawPutResponse* New() const final {
    return CreateMaybeMessage<RawPutResponse>(NULL);
  }

  RawPutResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawPutResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawPutResponse& from);
  void MergeFrom(const RawPutResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawPutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawPutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawBatchPutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawBatchPutRequest) */ {
 public:
  RawBatchPutRequest();
  virtual ~RawBatchPutRequest();

  RawBatchPutRequest(const RawBatchPutRequest& from);

  inline RawBatchPutRequest& operator=(const RawBatchPutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawBatchPutRequest(RawBatchPutRequest&& from) noexcept
    : RawBatchPutRequest() {
    *this = ::std::move(from);
  }

  inline RawBatchPutRequest& operator=(RawBatchPutRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawBatchPutRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawBatchPutRequest* internal_default_instance() {
    return reinterpret_cast<const RawBatchPutRequest*>(
               &_RawBatchPutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(RawBatchPutRequest* other);
  friend void swap(RawBatchPutRequest& a, RawBatchPutRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawBatchPutRequest* New() const final {
    return CreateMaybeMessage<RawBatchPutRequest>(NULL);
  }

  RawBatchPutRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawBatchPutRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawBatchPutRequest& from);
  void MergeFrom(const RawBatchPutRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawBatchPutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KvPair pairs = 2;
  int pairs_size() const;
  void clear_pairs();
  static const int kPairsFieldNumber = 2;
  ::kvrpcpb::KvPair* mutable_pairs(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
      mutable_pairs();
  const ::kvrpcpb::KvPair& pairs(int index) const;
  ::kvrpcpb::KvPair* add_pairs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
      pairs() const;

  // string cf = 3;
  void clear_cf();
  static const int kCfFieldNumber = 3;
  const ::std::string& cf() const;
  void set_cf(const ::std::string& value);
  #if LANG_CXX11
  void set_cf(::std::string&& value);
  #endif
  void set_cf(const char* value);
  void set_cf(const char* value, size_t size);
  ::std::string* mutable_cf();
  ::std::string* release_cf();
  void set_allocated_cf(::std::string* cf);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawBatchPutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair > pairs_;
  ::google::protobuf::internal::ArenaStringPtr cf_;
  ::kvrpcpb::Context* context_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawBatchPutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawBatchPutResponse) */ {
 public:
  RawBatchPutResponse();
  virtual ~RawBatchPutResponse();

  RawBatchPutResponse(const RawBatchPutResponse& from);

  inline RawBatchPutResponse& operator=(const RawBatchPutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawBatchPutResponse(RawBatchPutResponse&& from) noexcept
    : RawBatchPutResponse() {
    *this = ::std::move(from);
  }

  inline RawBatchPutResponse& operator=(RawBatchPutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawBatchPutResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawBatchPutResponse* internal_default_instance() {
    return reinterpret_cast<const RawBatchPutResponse*>(
               &_RawBatchPutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(RawBatchPutResponse* other);
  friend void swap(RawBatchPutResponse& a, RawBatchPutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawBatchPutResponse* New() const final {
    return CreateMaybeMessage<RawBatchPutResponse>(NULL);
  }

  RawBatchPutResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawBatchPutResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawBatchPutResponse& from);
  void MergeFrom(const RawBatchPutResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawBatchPutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawBatchPutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawBatchGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawBatchGetRequest) */ {
 public:
  RawBatchGetRequest();
  virtual ~RawBatchGetRequest();

  RawBatchGetRequest(const RawBatchGetRequest& from);

  inline RawBatchGetRequest& operator=(const RawBatchGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawBatchGetRequest(RawBatchGetRequest&& from) noexcept
    : RawBatchGetRequest() {
    *this = ::std::move(from);
  }

  inline RawBatchGetRequest& operator=(RawBatchGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawBatchGetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawBatchGetRequest* internal_default_instance() {
    return reinterpret_cast<const RawBatchGetRequest*>(
               &_RawBatchGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(RawBatchGetRequest* other);
  friend void swap(RawBatchGetRequest& a, RawBatchGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawBatchGetRequest* New() const final {
    return CreateMaybeMessage<RawBatchGetRequest>(NULL);
  }

  RawBatchGetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawBatchGetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawBatchGetRequest& from);
  void MergeFrom(const RawBatchGetRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawBatchGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 2;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // string cf = 3;
  void clear_cf();
  static const int kCfFieldNumber = 3;
  const ::std::string& cf() const;
  void set_cf(const ::std::string& value);
  #if LANG_CXX11
  void set_cf(::std::string&& value);
  #endif
  void set_cf(const char* value);
  void set_cf(const char* value, size_t size);
  ::std::string* mutable_cf();
  ::std::string* release_cf();
  void set_allocated_cf(::std::string* cf);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawBatchGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::internal::ArenaStringPtr cf_;
  ::kvrpcpb::Context* context_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawBatchGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawBatchGetResponse) */ {
 public:
  RawBatchGetResponse();
  virtual ~RawBatchGetResponse();

  RawBatchGetResponse(const RawBatchGetResponse& from);

  inline RawBatchGetResponse& operator=(const RawBatchGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawBatchGetResponse(RawBatchGetResponse&& from) noexcept
    : RawBatchGetResponse() {
    *this = ::std::move(from);
  }

  inline RawBatchGetResponse& operator=(RawBatchGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawBatchGetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawBatchGetResponse* internal_default_instance() {
    return reinterpret_cast<const RawBatchGetResponse*>(
               &_RawBatchGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(RawBatchGetResponse* other);
  friend void swap(RawBatchGetResponse& a, RawBatchGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawBatchGetResponse* New() const final {
    return CreateMaybeMessage<RawBatchGetResponse>(NULL);
  }

  RawBatchGetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawBatchGetResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawBatchGetResponse& from);
  void MergeFrom(const RawBatchGetResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawBatchGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KvPair pairs = 2;
  int pairs_size() const;
  void clear_pairs();
  static const int kPairsFieldNumber = 2;
  ::kvrpcpb::KvPair* mutable_pairs(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
      mutable_pairs();
  const ::kvrpcpb::KvPair& pairs(int index) const;
  ::kvrpcpb::KvPair* add_pairs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
      pairs() const;

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawBatchGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair > pairs_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawDeleteRequest) */ {
 public:
  RawDeleteRequest();
  virtual ~RawDeleteRequest();

  RawDeleteRequest(const RawDeleteRequest& from);

  inline RawDeleteRequest& operator=(const RawDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawDeleteRequest(RawDeleteRequest&& from) noexcept
    : RawDeleteRequest() {
    *this = ::std::move(from);
  }

  inline RawDeleteRequest& operator=(RawDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawDeleteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const RawDeleteRequest*>(
               &_RawDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(RawDeleteRequest* other);
  friend void swap(RawDeleteRequest& a, RawDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawDeleteRequest* New() const final {
    return CreateMaybeMessage<RawDeleteRequest>(NULL);
  }

  RawDeleteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawDeleteRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawDeleteRequest& from);
  void MergeFrom(const RawDeleteRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string cf = 3;
  void clear_cf();
  static const int kCfFieldNumber = 3;
  const ::std::string& cf() const;
  void set_cf(const ::std::string& value);
  #if LANG_CXX11
  void set_cf(::std::string&& value);
  #endif
  void set_cf(const char* value);
  void set_cf(const char* value, size_t size);
  ::std::string* mutable_cf();
  ::std::string* release_cf();
  void set_allocated_cf(::std::string* cf);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr cf_;
  ::kvrpcpb::Context* context_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawDeleteResponse) */ {
 public:
  RawDeleteResponse();
  virtual ~RawDeleteResponse();

  RawDeleteResponse(const RawDeleteResponse& from);

  inline RawDeleteResponse& operator=(const RawDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawDeleteResponse(RawDeleteResponse&& from) noexcept
    : RawDeleteResponse() {
    *this = ::std::move(from);
  }

  inline RawDeleteResponse& operator=(RawDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawDeleteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const RawDeleteResponse*>(
               &_RawDeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(RawDeleteResponse* other);
  friend void swap(RawDeleteResponse& a, RawDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawDeleteResponse* New() const final {
    return CreateMaybeMessage<RawDeleteResponse>(NULL);
  }

  RawDeleteResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawDeleteResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawDeleteResponse& from);
  void MergeFrom(const RawDeleteResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawBatchDeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawBatchDeleteRequest) */ {
 public:
  RawBatchDeleteRequest();
  virtual ~RawBatchDeleteRequest();

  RawBatchDeleteRequest(const RawBatchDeleteRequest& from);

  inline RawBatchDeleteRequest& operator=(const RawBatchDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawBatchDeleteRequest(RawBatchDeleteRequest&& from) noexcept
    : RawBatchDeleteRequest() {
    *this = ::std::move(from);
  }

  inline RawBatchDeleteRequest& operator=(RawBatchDeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawBatchDeleteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawBatchDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const RawBatchDeleteRequest*>(
               &_RawBatchDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(RawBatchDeleteRequest* other);
  friend void swap(RawBatchDeleteRequest& a, RawBatchDeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawBatchDeleteRequest* New() const final {
    return CreateMaybeMessage<RawBatchDeleteRequest>(NULL);
  }

  RawBatchDeleteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawBatchDeleteRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawBatchDeleteRequest& from);
  void MergeFrom(const RawBatchDeleteRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawBatchDeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 2;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // string cf = 3;
  void clear_cf();
  static const int kCfFieldNumber = 3;
  const ::std::string& cf() const;
  void set_cf(const ::std::string& value);
  #if LANG_CXX11
  void set_cf(::std::string&& value);
  #endif
  void set_cf(const char* value);
  void set_cf(const char* value, size_t size);
  ::std::string* mutable_cf();
  ::std::string* release_cf();
  void set_allocated_cf(::std::string* cf);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawBatchDeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::internal::ArenaStringPtr cf_;
  ::kvrpcpb::Context* context_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawBatchDeleteResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawBatchDeleteResponse) */ {
 public:
  RawBatchDeleteResponse();
  virtual ~RawBatchDeleteResponse();

  RawBatchDeleteResponse(const RawBatchDeleteResponse& from);

  inline RawBatchDeleteResponse& operator=(const RawBatchDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawBatchDeleteResponse(RawBatchDeleteResponse&& from) noexcept
    : RawBatchDeleteResponse() {
    *this = ::std::move(from);
  }

  inline RawBatchDeleteResponse& operator=(RawBatchDeleteResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawBatchDeleteResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawBatchDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const RawBatchDeleteResponse*>(
               &_RawBatchDeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(RawBatchDeleteResponse* other);
  friend void swap(RawBatchDeleteResponse& a, RawBatchDeleteResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawBatchDeleteResponse* New() const final {
    return CreateMaybeMessage<RawBatchDeleteResponse>(NULL);
  }

  RawBatchDeleteResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawBatchDeleteResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawBatchDeleteResponse& from);
  void MergeFrom(const RawBatchDeleteResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawBatchDeleteResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawBatchDeleteResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DeleteRangeRequest) */ {
 public:
  DeleteRangeRequest();
  virtual ~DeleteRangeRequest();

  DeleteRangeRequest(const DeleteRangeRequest& from);

  inline DeleteRangeRequest& operator=(const DeleteRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRangeRequest(DeleteRangeRequest&& from) noexcept
    : DeleteRangeRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRangeRequest& operator=(DeleteRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRangeRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRangeRequest*>(
               &_DeleteRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(DeleteRangeRequest* other);
  friend void swap(DeleteRangeRequest& a, DeleteRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRangeRequest* New() const final {
    return CreateMaybeMessage<DeleteRangeRequest>(NULL);
  }

  DeleteRangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRangeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteRangeRequest& from);
  void MergeFrom(const DeleteRangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start_key = 2;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 2;
  const ::std::string& start_key() const;
  void set_start_key(const ::std::string& value);
  #if LANG_CXX11
  void set_start_key(::std::string&& value);
  #endif
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  ::std::string* mutable_start_key();
  ::std::string* release_start_key();
  void set_allocated_start_key(::std::string* start_key);

  // bytes end_key = 3;
  void clear_end_key();
  static const int kEndKeyFieldNumber = 3;
  const ::std::string& end_key() const;
  void set_end_key(const ::std::string& value);
  #if LANG_CXX11
  void set_end_key(::std::string&& value);
  #endif
  void set_end_key(const char* value);
  void set_end_key(const void* value, size_t size);
  ::std::string* mutable_end_key();
  ::std::string* release_end_key();
  void set_allocated_end_key(::std::string* end_key);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DeleteRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_key_;
  ::google::protobuf::internal::ArenaStringPtr end_key_;
  ::kvrpcpb::Context* context_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRangeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.DeleteRangeResponse) */ {
 public:
  DeleteRangeResponse();
  virtual ~DeleteRangeResponse();

  DeleteRangeResponse(const DeleteRangeResponse& from);

  inline DeleteRangeResponse& operator=(const DeleteRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRangeResponse(DeleteRangeResponse&& from) noexcept
    : DeleteRangeResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRangeResponse& operator=(DeleteRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRangeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRangeResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRangeResponse*>(
               &_DeleteRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(DeleteRangeResponse* other);
  friend void swap(DeleteRangeResponse& a, DeleteRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRangeResponse* New() const final {
    return CreateMaybeMessage<DeleteRangeResponse>(NULL);
  }

  DeleteRangeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRangeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteRangeResponse& from);
  void MergeFrom(const DeleteRangeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.DeleteRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawDeleteRangeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawDeleteRangeRequest) */ {
 public:
  RawDeleteRangeRequest();
  virtual ~RawDeleteRangeRequest();

  RawDeleteRangeRequest(const RawDeleteRangeRequest& from);

  inline RawDeleteRangeRequest& operator=(const RawDeleteRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawDeleteRangeRequest(RawDeleteRangeRequest&& from) noexcept
    : RawDeleteRangeRequest() {
    *this = ::std::move(from);
  }

  inline RawDeleteRangeRequest& operator=(RawDeleteRangeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawDeleteRangeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawDeleteRangeRequest* internal_default_instance() {
    return reinterpret_cast<const RawDeleteRangeRequest*>(
               &_RawDeleteRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(RawDeleteRangeRequest* other);
  friend void swap(RawDeleteRangeRequest& a, RawDeleteRangeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawDeleteRangeRequest* New() const final {
    return CreateMaybeMessage<RawDeleteRangeRequest>(NULL);
  }

  RawDeleteRangeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawDeleteRangeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawDeleteRangeRequest& from);
  void MergeFrom(const RawDeleteRangeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawDeleteRangeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start_key = 2;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 2;
  const ::std::string& start_key() const;
  void set_start_key(const ::std::string& value);
  #if LANG_CXX11
  void set_start_key(::std::string&& value);
  #endif
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  ::std::string* mutable_start_key();
  ::std::string* release_start_key();
  void set_allocated_start_key(::std::string* start_key);

  // bytes end_key = 3;
  void clear_end_key();
  static const int kEndKeyFieldNumber = 3;
  const ::std::string& end_key() const;
  void set_end_key(const ::std::string& value);
  #if LANG_CXX11
  void set_end_key(::std::string&& value);
  #endif
  void set_end_key(const char* value);
  void set_end_key(const void* value, size_t size);
  ::std::string* mutable_end_key();
  ::std::string* release_end_key();
  void set_allocated_end_key(::std::string* end_key);

  // string cf = 4;
  void clear_cf();
  static const int kCfFieldNumber = 4;
  const ::std::string& cf() const;
  void set_cf(const ::std::string& value);
  #if LANG_CXX11
  void set_cf(::std::string&& value);
  #endif
  void set_cf(const char* value);
  void set_cf(const char* value, size_t size);
  ::std::string* mutable_cf();
  ::std::string* release_cf();
  void set_allocated_cf(::std::string* cf);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawDeleteRangeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_key_;
  ::google::protobuf::internal::ArenaStringPtr end_key_;
  ::google::protobuf::internal::ArenaStringPtr cf_;
  ::kvrpcpb::Context* context_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawDeleteRangeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawDeleteRangeResponse) */ {
 public:
  RawDeleteRangeResponse();
  virtual ~RawDeleteRangeResponse();

  RawDeleteRangeResponse(const RawDeleteRangeResponse& from);

  inline RawDeleteRangeResponse& operator=(const RawDeleteRangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawDeleteRangeResponse(RawDeleteRangeResponse&& from) noexcept
    : RawDeleteRangeResponse() {
    *this = ::std::move(from);
  }

  inline RawDeleteRangeResponse& operator=(RawDeleteRangeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawDeleteRangeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawDeleteRangeResponse* internal_default_instance() {
    return reinterpret_cast<const RawDeleteRangeResponse*>(
               &_RawDeleteRangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(RawDeleteRangeResponse* other);
  friend void swap(RawDeleteRangeResponse& a, RawDeleteRangeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawDeleteRangeResponse* New() const final {
    return CreateMaybeMessage<RawDeleteRangeResponse>(NULL);
  }

  RawDeleteRangeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawDeleteRangeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawDeleteRangeResponse& from);
  void MergeFrom(const RawDeleteRangeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawDeleteRangeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawDeleteRangeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawScanRequest) */ {
 public:
  RawScanRequest();
  virtual ~RawScanRequest();

  RawScanRequest(const RawScanRequest& from);

  inline RawScanRequest& operator=(const RawScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawScanRequest(RawScanRequest&& from) noexcept
    : RawScanRequest() {
    *this = ::std::move(from);
  }

  inline RawScanRequest& operator=(RawScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawScanRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawScanRequest* internal_default_instance() {
    return reinterpret_cast<const RawScanRequest*>(
               &_RawScanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(RawScanRequest* other);
  friend void swap(RawScanRequest& a, RawScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawScanRequest* New() const final {
    return CreateMaybeMessage<RawScanRequest>(NULL);
  }

  RawScanRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawScanRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawScanRequest& from);
  void MergeFrom(const RawScanRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start_key = 2;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 2;
  const ::std::string& start_key() const;
  void set_start_key(const ::std::string& value);
  #if LANG_CXX11
  void set_start_key(::std::string&& value);
  #endif
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  ::std::string* mutable_start_key();
  ::std::string* release_start_key();
  void set_allocated_start_key(::std::string* start_key);

  // string cf = 5;
  void clear_cf();
  static const int kCfFieldNumber = 5;
  const ::std::string& cf() const;
  void set_cf(const ::std::string& value);
  #if LANG_CXX11
  void set_cf(::std::string&& value);
  #endif
  void set_cf(const char* value);
  void set_cf(const char* value, size_t size);
  ::std::string* mutable_cf();
  ::std::string* release_cf();
  void set_allocated_cf(::std::string* cf);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint32 limit = 3;
  void clear_limit();
  static const int kLimitFieldNumber = 3;
  ::google::protobuf::uint32 limit() const;
  void set_limit(::google::protobuf::uint32 value);

  // bool key_only = 4;
  void clear_key_only();
  static const int kKeyOnlyFieldNumber = 4;
  bool key_only() const;
  void set_key_only(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_key_;
  ::google::protobuf::internal::ArenaStringPtr cf_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint32 limit_;
  bool key_only_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawScanResponse) */ {
 public:
  RawScanResponse();
  virtual ~RawScanResponse();

  RawScanResponse(const RawScanResponse& from);

  inline RawScanResponse& operator=(const RawScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawScanResponse(RawScanResponse&& from) noexcept
    : RawScanResponse() {
    *this = ::std::move(from);
  }

  inline RawScanResponse& operator=(RawScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawScanResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawScanResponse* internal_default_instance() {
    return reinterpret_cast<const RawScanResponse*>(
               &_RawScanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(RawScanResponse* other);
  friend void swap(RawScanResponse& a, RawScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawScanResponse* New() const final {
    return CreateMaybeMessage<RawScanResponse>(NULL);
  }

  RawScanResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawScanResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawScanResponse& from);
  void MergeFrom(const RawScanResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KvPair kvs = 2;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 2;
  ::kvrpcpb::KvPair* mutable_kvs(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
      mutable_kvs();
  const ::kvrpcpb::KvPair& kvs(int index) const;
  ::kvrpcpb::KvPair* add_kvs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
      kvs() const;

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair > kvs_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.KeyRange) */ {
 public:
  KeyRange();
  virtual ~KeyRange();

  KeyRange(const KeyRange& from);

  inline KeyRange& operator=(const KeyRange& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyRange(KeyRange&& from) noexcept
    : KeyRange() {
    *this = ::std::move(from);
  }

  inline KeyRange& operator=(KeyRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyRange* internal_default_instance() {
    return reinterpret_cast<const KeyRange*>(
               &_KeyRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(KeyRange* other);
  friend void swap(KeyRange& a, KeyRange& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyRange* New() const final {
    return CreateMaybeMessage<KeyRange>(NULL);
  }

  KeyRange* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyRange>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyRange& from);
  void MergeFrom(const KeyRange& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes start_key = 1;
  void clear_start_key();
  static const int kStartKeyFieldNumber = 1;
  const ::std::string& start_key() const;
  void set_start_key(const ::std::string& value);
  #if LANG_CXX11
  void set_start_key(::std::string&& value);
  #endif
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  ::std::string* mutable_start_key();
  ::std::string* release_start_key();
  void set_allocated_start_key(::std::string* start_key);

  // bytes end_key = 2;
  void clear_end_key();
  static const int kEndKeyFieldNumber = 2;
  const ::std::string& end_key() const;
  void set_end_key(const ::std::string& value);
  #if LANG_CXX11
  void set_end_key(::std::string&& value);
  #endif
  void set_end_key(const char* value);
  void set_end_key(const void* value, size_t size);
  ::std::string* mutable_end_key();
  ::std::string* release_end_key();
  void set_allocated_end_key(::std::string* end_key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KeyRange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr start_key_;
  ::google::protobuf::internal::ArenaStringPtr end_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawBatchScanRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawBatchScanRequest) */ {
 public:
  RawBatchScanRequest();
  virtual ~RawBatchScanRequest();

  RawBatchScanRequest(const RawBatchScanRequest& from);

  inline RawBatchScanRequest& operator=(const RawBatchScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawBatchScanRequest(RawBatchScanRequest&& from) noexcept
    : RawBatchScanRequest() {
    *this = ::std::move(from);
  }

  inline RawBatchScanRequest& operator=(RawBatchScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawBatchScanRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawBatchScanRequest* internal_default_instance() {
    return reinterpret_cast<const RawBatchScanRequest*>(
               &_RawBatchScanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(RawBatchScanRequest* other);
  friend void swap(RawBatchScanRequest& a, RawBatchScanRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawBatchScanRequest* New() const final {
    return CreateMaybeMessage<RawBatchScanRequest>(NULL);
  }

  RawBatchScanRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawBatchScanRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawBatchScanRequest& from);
  void MergeFrom(const RawBatchScanRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawBatchScanRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KeyRange ranges = 2;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 2;
  ::kvrpcpb::KeyRange* mutable_ranges(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyRange >*
      mutable_ranges();
  const ::kvrpcpb::KeyRange& ranges(int index) const;
  ::kvrpcpb::KeyRange* add_ranges();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyRange >&
      ranges() const;

  // string cf = 5;
  void clear_cf();
  static const int kCfFieldNumber = 5;
  const ::std::string& cf() const;
  void set_cf(const ::std::string& value);
  #if LANG_CXX11
  void set_cf(::std::string&& value);
  #endif
  void set_cf(const char* value);
  void set_cf(const char* value, size_t size);
  ::std::string* mutable_cf();
  ::std::string* release_cf();
  void set_allocated_cf(::std::string* cf);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint32 each_limit = 3;
  void clear_each_limit();
  static const int kEachLimitFieldNumber = 3;
  ::google::protobuf::uint32 each_limit() const;
  void set_each_limit(::google::protobuf::uint32 value);

  // bool key_only = 4;
  void clear_key_only();
  static const int kKeyOnlyFieldNumber = 4;
  bool key_only() const;
  void set_key_only(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawBatchScanRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyRange > ranges_;
  ::google::protobuf::internal::ArenaStringPtr cf_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint32 each_limit_;
  bool key_only_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RawBatchScanResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.RawBatchScanResponse) */ {
 public:
  RawBatchScanResponse();
  virtual ~RawBatchScanResponse();

  RawBatchScanResponse(const RawBatchScanResponse& from);

  inline RawBatchScanResponse& operator=(const RawBatchScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RawBatchScanResponse(RawBatchScanResponse&& from) noexcept
    : RawBatchScanResponse() {
    *this = ::std::move(from);
  }

  inline RawBatchScanResponse& operator=(RawBatchScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RawBatchScanResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RawBatchScanResponse* internal_default_instance() {
    return reinterpret_cast<const RawBatchScanResponse*>(
               &_RawBatchScanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(RawBatchScanResponse* other);
  friend void swap(RawBatchScanResponse& a, RawBatchScanResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RawBatchScanResponse* New() const final {
    return CreateMaybeMessage<RawBatchScanResponse>(NULL);
  }

  RawBatchScanResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RawBatchScanResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RawBatchScanResponse& from);
  void MergeFrom(const RawBatchScanResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawBatchScanResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KvPair kvs = 2;
  int kvs_size() const;
  void clear_kvs();
  static const int kKvsFieldNumber = 2;
  ::kvrpcpb::KvPair* mutable_kvs(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
      mutable_kvs();
  const ::kvrpcpb::KvPair& kvs(int index) const;
  ::kvrpcpb::KvPair* add_kvs();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
      kvs() const;

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.RawBatchScanResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair > kvs_;
  ::errorpb::Error* region_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MvccWrite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.MvccWrite) */ {
 public:
  MvccWrite();
  virtual ~MvccWrite();

  MvccWrite(const MvccWrite& from);

  inline MvccWrite& operator=(const MvccWrite& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MvccWrite(MvccWrite&& from) noexcept
    : MvccWrite() {
    *this = ::std::move(from);
  }

  inline MvccWrite& operator=(MvccWrite&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MvccWrite& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MvccWrite* internal_default_instance() {
    return reinterpret_cast<const MvccWrite*>(
               &_MvccWrite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(MvccWrite* other);
  friend void swap(MvccWrite& a, MvccWrite& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MvccWrite* New() const final {
    return CreateMaybeMessage<MvccWrite>(NULL);
  }

  MvccWrite* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MvccWrite>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MvccWrite& from);
  void MergeFrom(const MvccWrite& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MvccWrite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes short_value = 4;
  void clear_short_value();
  static const int kShortValueFieldNumber = 4;
  const ::std::string& short_value() const;
  void set_short_value(const ::std::string& value);
  #if LANG_CXX11
  void set_short_value(::std::string&& value);
  #endif
  void set_short_value(const char* value);
  void set_short_value(const void* value, size_t size);
  ::std::string* mutable_short_value();
  ::std::string* release_short_value();
  void set_allocated_short_value(::std::string* short_value);

  // uint64 start_ts = 2;
  void clear_start_ts();
  static const int kStartTsFieldNumber = 2;
  ::google::protobuf::uint64 start_ts() const;
  void set_start_ts(::google::protobuf::uint64 value);

  // uint64 commit_ts = 3;
  void clear_commit_ts();
  static const int kCommitTsFieldNumber = 3;
  ::google::protobuf::uint64 commit_ts() const;
  void set_commit_ts(::google::protobuf::uint64 value);

  // .kvrpcpb.Op type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::kvrpcpb::Op type() const;
  void set_type(::kvrpcpb::Op value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.MvccWrite)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr short_value_;
  ::google::protobuf::uint64 start_ts_;
  ::google::protobuf::uint64 commit_ts_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MvccValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.MvccValue) */ {
 public:
  MvccValue();
  virtual ~MvccValue();

  MvccValue(const MvccValue& from);

  inline MvccValue& operator=(const MvccValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MvccValue(MvccValue&& from) noexcept
    : MvccValue() {
    *this = ::std::move(from);
  }

  inline MvccValue& operator=(MvccValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MvccValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MvccValue* internal_default_instance() {
    return reinterpret_cast<const MvccValue*>(
               &_MvccValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(MvccValue* other);
  friend void swap(MvccValue& a, MvccValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MvccValue* New() const final {
    return CreateMaybeMessage<MvccValue>(NULL);
  }

  MvccValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MvccValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MvccValue& from);
  void MergeFrom(const MvccValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MvccValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // uint64 start_ts = 1;
  void clear_start_ts();
  static const int kStartTsFieldNumber = 1;
  ::google::protobuf::uint64 start_ts() const;
  void set_start_ts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.MvccValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint64 start_ts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MvccLock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.MvccLock) */ {
 public:
  MvccLock();
  virtual ~MvccLock();

  MvccLock(const MvccLock& from);

  inline MvccLock& operator=(const MvccLock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MvccLock(MvccLock&& from) noexcept
    : MvccLock() {
    *this = ::std::move(from);
  }

  inline MvccLock& operator=(MvccLock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MvccLock& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MvccLock* internal_default_instance() {
    return reinterpret_cast<const MvccLock*>(
               &_MvccLock_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(MvccLock* other);
  friend void swap(MvccLock& a, MvccLock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MvccLock* New() const final {
    return CreateMaybeMessage<MvccLock>(NULL);
  }

  MvccLock* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MvccLock>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MvccLock& from);
  void MergeFrom(const MvccLock& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MvccLock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes primary = 3;
  void clear_primary();
  static const int kPrimaryFieldNumber = 3;
  const ::std::string& primary() const;
  void set_primary(const ::std::string& value);
  #if LANG_CXX11
  void set_primary(::std::string&& value);
  #endif
  void set_primary(const char* value);
  void set_primary(const void* value, size_t size);
  ::std::string* mutable_primary();
  ::std::string* release_primary();
  void set_allocated_primary(::std::string* primary);

  // bytes short_value = 4;
  void clear_short_value();
  static const int kShortValueFieldNumber = 4;
  const ::std::string& short_value() const;
  void set_short_value(const ::std::string& value);
  #if LANG_CXX11
  void set_short_value(::std::string&& value);
  #endif
  void set_short_value(const char* value);
  void set_short_value(const void* value, size_t size);
  ::std::string* mutable_short_value();
  ::std::string* release_short_value();
  void set_allocated_short_value(::std::string* short_value);

  // uint64 start_ts = 2;
  void clear_start_ts();
  static const int kStartTsFieldNumber = 2;
  ::google::protobuf::uint64 start_ts() const;
  void set_start_ts(::google::protobuf::uint64 value);

  // .kvrpcpb.Op type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::kvrpcpb::Op type() const;
  void set_type(::kvrpcpb::Op value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.MvccLock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr primary_;
  ::google::protobuf::internal::ArenaStringPtr short_value_;
  ::google::protobuf::uint64 start_ts_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MvccInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.MvccInfo) */ {
 public:
  MvccInfo();
  virtual ~MvccInfo();

  MvccInfo(const MvccInfo& from);

  inline MvccInfo& operator=(const MvccInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MvccInfo(MvccInfo&& from) noexcept
    : MvccInfo() {
    *this = ::std::move(from);
  }

  inline MvccInfo& operator=(MvccInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MvccInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MvccInfo* internal_default_instance() {
    return reinterpret_cast<const MvccInfo*>(
               &_MvccInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(MvccInfo* other);
  friend void swap(MvccInfo& a, MvccInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MvccInfo* New() const final {
    return CreateMaybeMessage<MvccInfo>(NULL);
  }

  MvccInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MvccInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MvccInfo& from);
  void MergeFrom(const MvccInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MvccInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.MvccWrite writes = 2;
  int writes_size() const;
  void clear_writes();
  static const int kWritesFieldNumber = 2;
  ::kvrpcpb::MvccWrite* mutable_writes(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::MvccWrite >*
      mutable_writes();
  const ::kvrpcpb::MvccWrite& writes(int index) const;
  ::kvrpcpb::MvccWrite* add_writes();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::MvccWrite >&
      writes() const;

  // repeated .kvrpcpb.MvccValue values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  ::kvrpcpb::MvccValue* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::MvccValue >*
      mutable_values();
  const ::kvrpcpb::MvccValue& values(int index) const;
  ::kvrpcpb::MvccValue* add_values();
  const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::MvccValue >&
      values() const;

  // .kvrpcpb.MvccLock lock = 1;
  bool has_lock() const;
  void clear_lock();
  static const int kLockFieldNumber = 1;
  private:
  const ::kvrpcpb::MvccLock& _internal_lock() const;
  public:
  const ::kvrpcpb::MvccLock& lock() const;
  ::kvrpcpb::MvccLock* release_lock();
  ::kvrpcpb::MvccLock* mutable_lock();
  void set_allocated_lock(::kvrpcpb::MvccLock* lock);

  // @@protoc_insertion_point(class_scope:kvrpcpb.MvccInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::MvccWrite > writes_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::MvccValue > values_;
  ::kvrpcpb::MvccLock* lock_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MvccGetByKeyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.MvccGetByKeyRequest) */ {
 public:
  MvccGetByKeyRequest();
  virtual ~MvccGetByKeyRequest();

  MvccGetByKeyRequest(const MvccGetByKeyRequest& from);

  inline MvccGetByKeyRequest& operator=(const MvccGetByKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MvccGetByKeyRequest(MvccGetByKeyRequest&& from) noexcept
    : MvccGetByKeyRequest() {
    *this = ::std::move(from);
  }

  inline MvccGetByKeyRequest& operator=(MvccGetByKeyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MvccGetByKeyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MvccGetByKeyRequest* internal_default_instance() {
    return reinterpret_cast<const MvccGetByKeyRequest*>(
               &_MvccGetByKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(MvccGetByKeyRequest* other);
  friend void swap(MvccGetByKeyRequest& a, MvccGetByKeyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MvccGetByKeyRequest* New() const final {
    return CreateMaybeMessage<MvccGetByKeyRequest>(NULL);
  }

  MvccGetByKeyRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MvccGetByKeyRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MvccGetByKeyRequest& from);
  void MergeFrom(const MvccGetByKeyRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MvccGetByKeyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // @@protoc_insertion_point(class_scope:kvrpcpb.MvccGetByKeyRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::kvrpcpb::Context* context_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MvccGetByKeyResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.MvccGetByKeyResponse) */ {
 public:
  MvccGetByKeyResponse();
  virtual ~MvccGetByKeyResponse();

  MvccGetByKeyResponse(const MvccGetByKeyResponse& from);

  inline MvccGetByKeyResponse& operator=(const MvccGetByKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MvccGetByKeyResponse(MvccGetByKeyResponse&& from) noexcept
    : MvccGetByKeyResponse() {
    *this = ::std::move(from);
  }

  inline MvccGetByKeyResponse& operator=(MvccGetByKeyResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MvccGetByKeyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MvccGetByKeyResponse* internal_default_instance() {
    return reinterpret_cast<const MvccGetByKeyResponse*>(
               &_MvccGetByKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(MvccGetByKeyResponse* other);
  friend void swap(MvccGetByKeyResponse& a, MvccGetByKeyResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MvccGetByKeyResponse* New() const final {
    return CreateMaybeMessage<MvccGetByKeyResponse>(NULL);
  }

  MvccGetByKeyResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MvccGetByKeyResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MvccGetByKeyResponse& from);
  void MergeFrom(const MvccGetByKeyResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MvccGetByKeyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // .kvrpcpb.MvccInfo info = 3;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 3;
  private:
  const ::kvrpcpb::MvccInfo& _internal_info() const;
  public:
  const ::kvrpcpb::MvccInfo& info() const;
  ::kvrpcpb::MvccInfo* release_info();
  ::kvrpcpb::MvccInfo* mutable_info();
  void set_allocated_info(::kvrpcpb::MvccInfo* info);

  // @@protoc_insertion_point(class_scope:kvrpcpb.MvccGetByKeyResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::errorpb::Error* region_error_;
  ::kvrpcpb::MvccInfo* info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MvccGetByStartTsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.MvccGetByStartTsRequest) */ {
 public:
  MvccGetByStartTsRequest();
  virtual ~MvccGetByStartTsRequest();

  MvccGetByStartTsRequest(const MvccGetByStartTsRequest& from);

  inline MvccGetByStartTsRequest& operator=(const MvccGetByStartTsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MvccGetByStartTsRequest(MvccGetByStartTsRequest&& from) noexcept
    : MvccGetByStartTsRequest() {
    *this = ::std::move(from);
  }

  inline MvccGetByStartTsRequest& operator=(MvccGetByStartTsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MvccGetByStartTsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MvccGetByStartTsRequest* internal_default_instance() {
    return reinterpret_cast<const MvccGetByStartTsRequest*>(
               &_MvccGetByStartTsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(MvccGetByStartTsRequest* other);
  friend void swap(MvccGetByStartTsRequest& a, MvccGetByStartTsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MvccGetByStartTsRequest* New() const final {
    return CreateMaybeMessage<MvccGetByStartTsRequest>(NULL);
  }

  MvccGetByStartTsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MvccGetByStartTsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MvccGetByStartTsRequest& from);
  void MergeFrom(const MvccGetByStartTsRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MvccGetByStartTsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // uint64 start_ts = 2;
  void clear_start_ts();
  static const int kStartTsFieldNumber = 2;
  ::google::protobuf::uint64 start_ts() const;
  void set_start_ts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.MvccGetByStartTsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::kvrpcpb::Context* context_;
  ::google::protobuf::uint64 start_ts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MvccGetByStartTsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.MvccGetByStartTsResponse) */ {
 public:
  MvccGetByStartTsResponse();
  virtual ~MvccGetByStartTsResponse();

  MvccGetByStartTsResponse(const MvccGetByStartTsResponse& from);

  inline MvccGetByStartTsResponse& operator=(const MvccGetByStartTsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MvccGetByStartTsResponse(MvccGetByStartTsResponse&& from) noexcept
    : MvccGetByStartTsResponse() {
    *this = ::std::move(from);
  }

  inline MvccGetByStartTsResponse& operator=(MvccGetByStartTsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MvccGetByStartTsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MvccGetByStartTsResponse* internal_default_instance() {
    return reinterpret_cast<const MvccGetByStartTsResponse*>(
               &_MvccGetByStartTsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(MvccGetByStartTsResponse* other);
  friend void swap(MvccGetByStartTsResponse& a, MvccGetByStartTsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MvccGetByStartTsResponse* New() const final {
    return CreateMaybeMessage<MvccGetByStartTsResponse>(NULL);
  }

  MvccGetByStartTsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MvccGetByStartTsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MvccGetByStartTsResponse& from);
  void MergeFrom(const MvccGetByStartTsResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MvccGetByStartTsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // bytes key = 3;
  void clear_key();
  static const int kKeyFieldNumber = 3;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // .kvrpcpb.MvccInfo info = 4;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  private:
  const ::kvrpcpb::MvccInfo& _internal_info() const;
  public:
  const ::kvrpcpb::MvccInfo& info() const;
  ::kvrpcpb::MvccInfo* release_info();
  ::kvrpcpb::MvccInfo* mutable_info();
  void set_allocated_info(::kvrpcpb::MvccInfo* info);

  // @@protoc_insertion_point(class_scope:kvrpcpb.MvccGetByStartTsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::errorpb::Error* region_error_;
  ::kvrpcpb::MvccInfo* info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SplitRegionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.SplitRegionRequest) */ {
 public:
  SplitRegionRequest();
  virtual ~SplitRegionRequest();

  SplitRegionRequest(const SplitRegionRequest& from);

  inline SplitRegionRequest& operator=(const SplitRegionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SplitRegionRequest(SplitRegionRequest&& from) noexcept
    : SplitRegionRequest() {
    *this = ::std::move(from);
  }

  inline SplitRegionRequest& operator=(SplitRegionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitRegionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplitRegionRequest* internal_default_instance() {
    return reinterpret_cast<const SplitRegionRequest*>(
               &_SplitRegionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(SplitRegionRequest* other);
  friend void swap(SplitRegionRequest& a, SplitRegionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SplitRegionRequest* New() const final {
    return CreateMaybeMessage<SplitRegionRequest>(NULL);
  }

  SplitRegionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SplitRegionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SplitRegionRequest& from);
  void MergeFrom(const SplitRegionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplitRegionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes split_key = 2;
  void clear_split_key();
  static const int kSplitKeyFieldNumber = 2;
  const ::std::string& split_key() const;
  void set_split_key(const ::std::string& value);
  #if LANG_CXX11
  void set_split_key(::std::string&& value);
  #endif
  void set_split_key(const char* value);
  void set_split_key(const void* value, size_t size);
  ::std::string* mutable_split_key();
  ::std::string* release_split_key();
  void set_allocated_split_key(::std::string* split_key);

  // .kvrpcpb.Context context = 1;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 1;
  private:
  const ::kvrpcpb::Context& _internal_context() const;
  public:
  const ::kvrpcpb::Context& context() const;
  ::kvrpcpb::Context* release_context();
  ::kvrpcpb::Context* mutable_context();
  void set_allocated_context(::kvrpcpb::Context* context);

  // @@protoc_insertion_point(class_scope:kvrpcpb.SplitRegionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr split_key_;
  ::kvrpcpb::Context* context_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SplitRegionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:kvrpcpb.SplitRegionResponse) */ {
 public:
  SplitRegionResponse();
  virtual ~SplitRegionResponse();

  SplitRegionResponse(const SplitRegionResponse& from);

  inline SplitRegionResponse& operator=(const SplitRegionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SplitRegionResponse(SplitRegionResponse&& from) noexcept
    : SplitRegionResponse() {
    *this = ::std::move(from);
  }

  inline SplitRegionResponse& operator=(SplitRegionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SplitRegionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplitRegionResponse* internal_default_instance() {
    return reinterpret_cast<const SplitRegionResponse*>(
               &_SplitRegionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(SplitRegionResponse* other);
  friend void swap(SplitRegionResponse& a, SplitRegionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SplitRegionResponse* New() const final {
    return CreateMaybeMessage<SplitRegionResponse>(NULL);
  }

  SplitRegionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SplitRegionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SplitRegionResponse& from);
  void MergeFrom(const SplitRegionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplitRegionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .errorpb.Error region_error = 1;
  bool has_region_error() const;
  void clear_region_error();
  static const int kRegionErrorFieldNumber = 1;
  private:
  const ::errorpb::Error& _internal_region_error() const;
  public:
  const ::errorpb::Error& region_error() const;
  ::errorpb::Error* release_region_error();
  ::errorpb::Error* mutable_region_error();
  void set_allocated_region_error(::errorpb::Error* region_error);

  // .metapb.Region left = 2;
  bool has_left() const;
  void clear_left();
  static const int kLeftFieldNumber = 2;
  private:
  const ::metapb::Region& _internal_left() const;
  public:
  const ::metapb::Region& left() const;
  ::metapb::Region* release_left();
  ::metapb::Region* mutable_left();
  void set_allocated_left(::metapb::Region* left);

  // .metapb.Region right = 3;
  bool has_right() const;
  void clear_right();
  static const int kRightFieldNumber = 3;
  private:
  const ::metapb::Region& _internal_right() const;
  public:
  const ::metapb::Region& right() const;
  ::metapb::Region* release_right();
  ::metapb::Region* mutable_right();
  void set_allocated_right(::metapb::Region* right);

  // @@protoc_insertion_point(class_scope:kvrpcpb.SplitRegionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::errorpb::Error* region_error_;
  ::metapb::Region* left_;
  ::metapb::Region* right_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_kvrpcpb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LockInfo

// bytes primary_lock = 1;
inline void LockInfo::clear_primary_lock() {
  primary_lock_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockInfo::primary_lock() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.primary_lock)
  return primary_lock_.GetNoArena();
}
inline void LockInfo::set_primary_lock(const ::std::string& value) {
  
  primary_lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockInfo.primary_lock)
}
#if LANG_CXX11
inline void LockInfo::set_primary_lock(::std::string&& value) {
  
  primary_lock_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockInfo.primary_lock)
}
#endif
inline void LockInfo::set_primary_lock(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockInfo.primary_lock)
}
inline void LockInfo::set_primary_lock(const void* value, size_t size) {
  
  primary_lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockInfo.primary_lock)
}
inline ::std::string* LockInfo::mutable_primary_lock() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockInfo.primary_lock)
  return primary_lock_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockInfo::release_primary_lock() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockInfo.primary_lock)
  
  return primary_lock_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockInfo::set_allocated_primary_lock(::std::string* primary_lock) {
  if (primary_lock != NULL) {
    
  } else {
    
  }
  primary_lock_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_lock);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockInfo.primary_lock)
}

// uint64 lock_version = 2;
inline void LockInfo::clear_lock_version() {
  lock_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LockInfo::lock_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.lock_version)
  return lock_version_;
}
inline void LockInfo::set_lock_version(::google::protobuf::uint64 value) {
  
  lock_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockInfo.lock_version)
}

// bytes key = 3;
inline void LockInfo::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LockInfo::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.key)
  return key_.GetNoArena();
}
inline void LockInfo::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockInfo.key)
}
#if LANG_CXX11
inline void LockInfo::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.LockInfo.key)
}
#endif
inline void LockInfo::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockInfo.key)
}
inline void LockInfo::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockInfo.key)
}
inline ::std::string* LockInfo::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockInfo.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LockInfo::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.LockInfo.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LockInfo::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockInfo.key)
}

// uint64 lock_ttl = 4;
inline void LockInfo::clear_lock_ttl() {
  lock_ttl_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LockInfo::lock_ttl() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.lock_ttl)
  return lock_ttl_;
}
inline void LockInfo::set_lock_ttl(::google::protobuf::uint64 value) {
  
  lock_ttl_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockInfo.lock_ttl)
}

// -------------------------------------------------------------------

// KeyError

// .kvrpcpb.LockInfo locked = 1;
inline bool KeyError::has_locked() const {
  return this != internal_default_instance() && locked_ != NULL;
}
inline void KeyError::clear_locked() {
  if (GetArenaNoVirtual() == NULL && locked_ != NULL) {
    delete locked_;
  }
  locked_ = NULL;
}
inline const ::kvrpcpb::LockInfo& KeyError::_internal_locked() const {
  return *locked_;
}
inline const ::kvrpcpb::LockInfo& KeyError::locked() const {
  const ::kvrpcpb::LockInfo* p = locked_;
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyError.locked)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::LockInfo*>(
      &::kvrpcpb::_LockInfo_default_instance_);
}
inline ::kvrpcpb::LockInfo* KeyError::release_locked() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KeyError.locked)
  
  ::kvrpcpb::LockInfo* temp = locked_;
  locked_ = NULL;
  return temp;
}
inline ::kvrpcpb::LockInfo* KeyError::mutable_locked() {
  
  if (locked_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::LockInfo>(GetArenaNoVirtual());
    locked_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyError.locked)
  return locked_;
}
inline void KeyError::set_allocated_locked(::kvrpcpb::LockInfo* locked) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete locked_;
  }
  if (locked) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      locked = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, locked, submessage_arena);
    }
    
  } else {
    
  }
  locked_ = locked;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyError.locked)
}

// string retryable = 2;
inline void KeyError::clear_retryable() {
  retryable_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyError::retryable() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyError.retryable)
  return retryable_.GetNoArena();
}
inline void KeyError::set_retryable(const ::std::string& value) {
  
  retryable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyError.retryable)
}
#if LANG_CXX11
inline void KeyError::set_retryable(::std::string&& value) {
  
  retryable_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KeyError.retryable)
}
#endif
inline void KeyError::set_retryable(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  retryable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KeyError.retryable)
}
inline void KeyError::set_retryable(const char* value, size_t size) {
  
  retryable_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KeyError.retryable)
}
inline ::std::string* KeyError::mutable_retryable() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyError.retryable)
  return retryable_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyError::release_retryable() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KeyError.retryable)
  
  return retryable_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyError::set_allocated_retryable(::std::string* retryable) {
  if (retryable != NULL) {
    
  } else {
    
  }
  retryable_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), retryable);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyError.retryable)
}

// string abort = 3;
inline void KeyError::clear_abort() {
  abort_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyError::abort() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyError.abort)
  return abort_.GetNoArena();
}
inline void KeyError::set_abort(const ::std::string& value) {
  
  abort_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyError.abort)
}
#if LANG_CXX11
inline void KeyError::set_abort(::std::string&& value) {
  
  abort_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KeyError.abort)
}
#endif
inline void KeyError::set_abort(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  abort_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KeyError.abort)
}
inline void KeyError::set_abort(const char* value, size_t size) {
  
  abort_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KeyError.abort)
}
inline ::std::string* KeyError::mutable_abort() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyError.abort)
  return abort_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyError::release_abort() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KeyError.abort)
  
  return abort_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyError::set_allocated_abort(::std::string* abort) {
  if (abort != NULL) {
    
  } else {
    
  }
  abort_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), abort);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyError.abort)
}

// .kvrpcpb.WriteConflict conflict = 4;
inline bool KeyError::has_conflict() const {
  return this != internal_default_instance() && conflict_ != NULL;
}
inline void KeyError::clear_conflict() {
  if (GetArenaNoVirtual() == NULL && conflict_ != NULL) {
    delete conflict_;
  }
  conflict_ = NULL;
}
inline const ::kvrpcpb::WriteConflict& KeyError::_internal_conflict() const {
  return *conflict_;
}
inline const ::kvrpcpb::WriteConflict& KeyError::conflict() const {
  const ::kvrpcpb::WriteConflict* p = conflict_;
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyError.conflict)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::WriteConflict*>(
      &::kvrpcpb::_WriteConflict_default_instance_);
}
inline ::kvrpcpb::WriteConflict* KeyError::release_conflict() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KeyError.conflict)
  
  ::kvrpcpb::WriteConflict* temp = conflict_;
  conflict_ = NULL;
  return temp;
}
inline ::kvrpcpb::WriteConflict* KeyError::mutable_conflict() {
  
  if (conflict_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::WriteConflict>(GetArenaNoVirtual());
    conflict_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyError.conflict)
  return conflict_;
}
inline void KeyError::set_allocated_conflict(::kvrpcpb::WriteConflict* conflict) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete conflict_;
  }
  if (conflict) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      conflict = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, conflict, submessage_arena);
    }
    
  } else {
    
  }
  conflict_ = conflict;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyError.conflict)
}

// -------------------------------------------------------------------

// WriteConflict

// uint64 start_ts = 1;
inline void WriteConflict::clear_start_ts() {
  start_ts_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 WriteConflict::start_ts() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.WriteConflict.start_ts)
  return start_ts_;
}
inline void WriteConflict::set_start_ts(::google::protobuf::uint64 value) {
  
  start_ts_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.WriteConflict.start_ts)
}

// uint64 conflict_ts = 2;
inline void WriteConflict::clear_conflict_ts() {
  conflict_ts_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 WriteConflict::conflict_ts() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.WriteConflict.conflict_ts)
  return conflict_ts_;
}
inline void WriteConflict::set_conflict_ts(::google::protobuf::uint64 value) {
  
  conflict_ts_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.WriteConflict.conflict_ts)
}

// bytes key = 3;
inline void WriteConflict::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteConflict::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.WriteConflict.key)
  return key_.GetNoArena();
}
inline void WriteConflict::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.WriteConflict.key)
}
#if LANG_CXX11
inline void WriteConflict::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.WriteConflict.key)
}
#endif
inline void WriteConflict::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.WriteConflict.key)
}
inline void WriteConflict::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.WriteConflict.key)
}
inline ::std::string* WriteConflict::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.WriteConflict.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteConflict::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.WriteConflict.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteConflict::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.WriteConflict.key)
}

// bytes primary = 4;
inline void WriteConflict::clear_primary() {
  primary_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteConflict::primary() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.WriteConflict.primary)
  return primary_.GetNoArena();
}
inline void WriteConflict::set_primary(const ::std::string& value) {
  
  primary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.WriteConflict.primary)
}
#if LANG_CXX11
inline void WriteConflict::set_primary(::std::string&& value) {
  
  primary_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.WriteConflict.primary)
}
#endif
inline void WriteConflict::set_primary(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.WriteConflict.primary)
}
inline void WriteConflict::set_primary(const void* value, size_t size) {
  
  primary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.WriteConflict.primary)
}
inline ::std::string* WriteConflict::mutable_primary() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.WriteConflict.primary)
  return primary_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteConflict::release_primary() {
  // @@protoc_insertion_point(field_release:kvrpcpb.WriteConflict.primary)
  
  return primary_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteConflict::set_allocated_primary(::std::string* primary) {
  if (primary != NULL) {
    
  } else {
    
  }
  primary_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.WriteConflict.primary)
}

// -------------------------------------------------------------------

// Context

// uint64 region_id = 1;
inline void Context::clear_region_id() {
  region_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Context::region_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.region_id)
  return region_id_;
}
inline void Context::set_region_id(::google::protobuf::uint64 value) {
  
  region_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.region_id)
}

// .metapb.RegionEpoch region_epoch = 2;
inline bool Context::has_region_epoch() const {
  return this != internal_default_instance() && region_epoch_ != NULL;
}
inline const ::metapb::RegionEpoch& Context::_internal_region_epoch() const {
  return *region_epoch_;
}
inline const ::metapb::RegionEpoch& Context::region_epoch() const {
  const ::metapb::RegionEpoch* p = region_epoch_;
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.region_epoch)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::RegionEpoch*>(
      &::metapb::_RegionEpoch_default_instance_);
}
inline ::metapb::RegionEpoch* Context::release_region_epoch() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Context.region_epoch)
  
  ::metapb::RegionEpoch* temp = region_epoch_;
  region_epoch_ = NULL;
  return temp;
}
inline ::metapb::RegionEpoch* Context::mutable_region_epoch() {
  
  if (region_epoch_ == NULL) {
    auto* p = CreateMaybeMessage<::metapb::RegionEpoch>(GetArenaNoVirtual());
    region_epoch_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Context.region_epoch)
  return region_epoch_;
}
inline void Context::set_allocated_region_epoch(::metapb::RegionEpoch* region_epoch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_epoch_);
  }
  if (region_epoch) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_epoch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_epoch, submessage_arena);
    }
    
  } else {
    
  }
  region_epoch_ = region_epoch;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Context.region_epoch)
}

// .metapb.Peer peer = 3;
inline bool Context::has_peer() const {
  return this != internal_default_instance() && peer_ != NULL;
}
inline const ::metapb::Peer& Context::_internal_peer() const {
  return *peer_;
}
inline const ::metapb::Peer& Context::peer() const {
  const ::metapb::Peer* p = peer_;
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.peer)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Peer*>(
      &::metapb::_Peer_default_instance_);
}
inline ::metapb::Peer* Context::release_peer() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Context.peer)
  
  ::metapb::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline ::metapb::Peer* Context::mutable_peer() {
  
  if (peer_ == NULL) {
    auto* p = CreateMaybeMessage<::metapb::Peer>(GetArenaNoVirtual());
    peer_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Context.peer)
  return peer_;
}
inline void Context::set_allocated_peer(::metapb::Peer* peer) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(peer_);
  }
  if (peer) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer, submessage_arena);
    }
    
  } else {
    
  }
  peer_ = peer;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Context.peer)
}

// uint64 term = 5;
inline void Context::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Context::term() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.term)
  return term_;
}
inline void Context::set_term(::google::protobuf::uint64 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.term)
}

// .kvrpcpb.CommandPri priority = 6;
inline void Context::clear_priority() {
  priority_ = 0;
}
inline ::kvrpcpb::CommandPri Context::priority() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.priority)
  return static_cast< ::kvrpcpb::CommandPri >(priority_);
}
inline void Context::set_priority(::kvrpcpb::CommandPri value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.priority)
}

// .kvrpcpb.IsolationLevel isolation_level = 7;
inline void Context::clear_isolation_level() {
  isolation_level_ = 0;
}
inline ::kvrpcpb::IsolationLevel Context::isolation_level() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.isolation_level)
  return static_cast< ::kvrpcpb::IsolationLevel >(isolation_level_);
}
inline void Context::set_isolation_level(::kvrpcpb::IsolationLevel value) {
  
  isolation_level_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.isolation_level)
}

// bool not_fill_cache = 8;
inline void Context::clear_not_fill_cache() {
  not_fill_cache_ = false;
}
inline bool Context::not_fill_cache() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.not_fill_cache)
  return not_fill_cache_;
}
inline void Context::set_not_fill_cache(bool value) {
  
  not_fill_cache_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.not_fill_cache)
}

// bool sync_log = 9;
inline void Context::clear_sync_log() {
  sync_log_ = false;
}
inline bool Context::sync_log() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.sync_log)
  return sync_log_;
}
inline void Context::set_sync_log(bool value) {
  
  sync_log_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.sync_log)
}

// bool handle_time = 10;
inline void Context::clear_handle_time() {
  handle_time_ = false;
}
inline bool Context::handle_time() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.handle_time)
  return handle_time_;
}
inline void Context::set_handle_time(bool value) {
  
  handle_time_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.handle_time)
}

// bool scan_detail = 11;
inline void Context::clear_scan_detail() {
  scan_detail_ = false;
}
inline bool Context::scan_detail() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.scan_detail)
  return scan_detail_;
}
inline void Context::set_scan_detail(bool value) {
  
  scan_detail_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.scan_detail)
}

// -------------------------------------------------------------------

// HandleTime

// int64 wait_ms = 1;
inline void HandleTime::clear_wait_ms() {
  wait_ms_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 HandleTime::wait_ms() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.HandleTime.wait_ms)
  return wait_ms_;
}
inline void HandleTime::set_wait_ms(::google::protobuf::int64 value) {
  
  wait_ms_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.HandleTime.wait_ms)
}

// int64 process_ms = 2;
inline void HandleTime::clear_process_ms() {
  process_ms_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 HandleTime::process_ms() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.HandleTime.process_ms)
  return process_ms_;
}
inline void HandleTime::set_process_ms(::google::protobuf::int64 value) {
  
  process_ms_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.HandleTime.process_ms)
}

// -------------------------------------------------------------------

// ScanInfo

// int64 total = 1;
inline void ScanInfo::clear_total() {
  total_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ScanInfo::total() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanInfo.total)
  return total_;
}
inline void ScanInfo::set_total(::google::protobuf::int64 value) {
  
  total_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ScanInfo.total)
}

// int64 processed = 2;
inline void ScanInfo::clear_processed() {
  processed_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ScanInfo::processed() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanInfo.processed)
  return processed_;
}
inline void ScanInfo::set_processed(::google::protobuf::int64 value) {
  
  processed_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ScanInfo.processed)
}

// -------------------------------------------------------------------

// ScanDetail

// .kvrpcpb.ScanInfo write = 1;
inline bool ScanDetail::has_write() const {
  return this != internal_default_instance() && write_ != NULL;
}
inline void ScanDetail::clear_write() {
  if (GetArenaNoVirtual() == NULL && write_ != NULL) {
    delete write_;
  }
  write_ = NULL;
}
inline const ::kvrpcpb::ScanInfo& ScanDetail::_internal_write() const {
  return *write_;
}
inline const ::kvrpcpb::ScanInfo& ScanDetail::write() const {
  const ::kvrpcpb::ScanInfo* p = write_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanDetail.write)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ScanInfo*>(
      &::kvrpcpb::_ScanInfo_default_instance_);
}
inline ::kvrpcpb::ScanInfo* ScanDetail::release_write() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ScanDetail.write)
  
  ::kvrpcpb::ScanInfo* temp = write_;
  write_ = NULL;
  return temp;
}
inline ::kvrpcpb::ScanInfo* ScanDetail::mutable_write() {
  
  if (write_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::ScanInfo>(GetArenaNoVirtual());
    write_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanDetail.write)
  return write_;
}
inline void ScanDetail::set_allocated_write(::kvrpcpb::ScanInfo* write) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete write_;
  }
  if (write) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      write = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, write, submessage_arena);
    }
    
  } else {
    
  }
  write_ = write;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ScanDetail.write)
}

// .kvrpcpb.ScanInfo lock = 2;
inline bool ScanDetail::has_lock() const {
  return this != internal_default_instance() && lock_ != NULL;
}
inline void ScanDetail::clear_lock() {
  if (GetArenaNoVirtual() == NULL && lock_ != NULL) {
    delete lock_;
  }
  lock_ = NULL;
}
inline const ::kvrpcpb::ScanInfo& ScanDetail::_internal_lock() const {
  return *lock_;
}
inline const ::kvrpcpb::ScanInfo& ScanDetail::lock() const {
  const ::kvrpcpb::ScanInfo* p = lock_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanDetail.lock)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ScanInfo*>(
      &::kvrpcpb::_ScanInfo_default_instance_);
}
inline ::kvrpcpb::ScanInfo* ScanDetail::release_lock() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ScanDetail.lock)
  
  ::kvrpcpb::ScanInfo* temp = lock_;
  lock_ = NULL;
  return temp;
}
inline ::kvrpcpb::ScanInfo* ScanDetail::mutable_lock() {
  
  if (lock_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::ScanInfo>(GetArenaNoVirtual());
    lock_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanDetail.lock)
  return lock_;
}
inline void ScanDetail::set_allocated_lock(::kvrpcpb::ScanInfo* lock) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lock_;
  }
  if (lock) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lock = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lock, submessage_arena);
    }
    
  } else {
    
  }
  lock_ = lock;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ScanDetail.lock)
}

// .kvrpcpb.ScanInfo data = 3;
inline bool ScanDetail::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void ScanDetail::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}
inline const ::kvrpcpb::ScanInfo& ScanDetail::_internal_data() const {
  return *data_;
}
inline const ::kvrpcpb::ScanInfo& ScanDetail::data() const {
  const ::kvrpcpb::ScanInfo* p = data_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanDetail.data)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ScanInfo*>(
      &::kvrpcpb::_ScanInfo_default_instance_);
}
inline ::kvrpcpb::ScanInfo* ScanDetail::release_data() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ScanDetail.data)
  
  ::kvrpcpb::ScanInfo* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::kvrpcpb::ScanInfo* ScanDetail::mutable_data() {
  
  if (data_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::ScanInfo>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanDetail.data)
  return data_;
}
inline void ScanDetail::set_allocated_data(::kvrpcpb::ScanInfo* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ScanDetail.data)
}

// -------------------------------------------------------------------

// ExecDetails

// .kvrpcpb.HandleTime handle_time = 1;
inline bool ExecDetails::has_handle_time() const {
  return this != internal_default_instance() && handle_time_ != NULL;
}
inline void ExecDetails::clear_handle_time() {
  if (GetArenaNoVirtual() == NULL && handle_time_ != NULL) {
    delete handle_time_;
  }
  handle_time_ = NULL;
}
inline const ::kvrpcpb::HandleTime& ExecDetails::_internal_handle_time() const {
  return *handle_time_;
}
inline const ::kvrpcpb::HandleTime& ExecDetails::handle_time() const {
  const ::kvrpcpb::HandleTime* p = handle_time_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ExecDetails.handle_time)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::HandleTime*>(
      &::kvrpcpb::_HandleTime_default_instance_);
}
inline ::kvrpcpb::HandleTime* ExecDetails::release_handle_time() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ExecDetails.handle_time)
  
  ::kvrpcpb::HandleTime* temp = handle_time_;
  handle_time_ = NULL;
  return temp;
}
inline ::kvrpcpb::HandleTime* ExecDetails::mutable_handle_time() {
  
  if (handle_time_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::HandleTime>(GetArenaNoVirtual());
    handle_time_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ExecDetails.handle_time)
  return handle_time_;
}
inline void ExecDetails::set_allocated_handle_time(::kvrpcpb::HandleTime* handle_time) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete handle_time_;
  }
  if (handle_time) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      handle_time = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, handle_time, submessage_arena);
    }
    
  } else {
    
  }
  handle_time_ = handle_time;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ExecDetails.handle_time)
}

// .kvrpcpb.ScanDetail scan_detail = 2;
inline bool ExecDetails::has_scan_detail() const {
  return this != internal_default_instance() && scan_detail_ != NULL;
}
inline void ExecDetails::clear_scan_detail() {
  if (GetArenaNoVirtual() == NULL && scan_detail_ != NULL) {
    delete scan_detail_;
  }
  scan_detail_ = NULL;
}
inline const ::kvrpcpb::ScanDetail& ExecDetails::_internal_scan_detail() const {
  return *scan_detail_;
}
inline const ::kvrpcpb::ScanDetail& ExecDetails::scan_detail() const {
  const ::kvrpcpb::ScanDetail* p = scan_detail_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ExecDetails.scan_detail)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::ScanDetail*>(
      &::kvrpcpb::_ScanDetail_default_instance_);
}
inline ::kvrpcpb::ScanDetail* ExecDetails::release_scan_detail() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ExecDetails.scan_detail)
  
  ::kvrpcpb::ScanDetail* temp = scan_detail_;
  scan_detail_ = NULL;
  return temp;
}
inline ::kvrpcpb::ScanDetail* ExecDetails::mutable_scan_detail() {
  
  if (scan_detail_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::ScanDetail>(GetArenaNoVirtual());
    scan_detail_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ExecDetails.scan_detail)
  return scan_detail_;
}
inline void ExecDetails::set_allocated_scan_detail(::kvrpcpb::ScanDetail* scan_detail) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scan_detail_;
  }
  if (scan_detail) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scan_detail = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scan_detail, submessage_arena);
    }
    
  } else {
    
  }
  scan_detail_ = scan_detail;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ExecDetails.scan_detail)
}

// -------------------------------------------------------------------

// GetRequest

// .kvrpcpb.Context context = 1;
inline bool GetRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void GetRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& GetRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& GetRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.GetRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* GetRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.GetRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* GetRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.GetRequest.context)
  return context_;
}
inline void GetRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.GetRequest.context)
}

// bytes key = 2;
inline void GetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.GetRequest.key)
  return key_.GetNoArena();
}
inline void GetRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.GetRequest.key)
}
#if LANG_CXX11
inline void GetRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.GetRequest.key)
}
#endif
inline void GetRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.GetRequest.key)
}
inline void GetRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.GetRequest.key)
}
inline ::std::string* GetRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.GetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.GetRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.GetRequest.key)
}

// uint64 version = 3;
inline void GetRequest::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetRequest::version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.GetRequest.version)
  return version_;
}
inline void GetRequest::set_version(::google::protobuf::uint64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.GetRequest.version)
}

// -------------------------------------------------------------------

// GetResponse

// .errorpb.Error region_error = 1;
inline bool GetResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& GetResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& GetResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.GetResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* GetResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.GetResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* GetResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.GetResponse.region_error)
  return region_error_;
}
inline void GetResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.GetResponse.region_error)
}

// .kvrpcpb.KeyError error = 2;
inline bool GetResponse::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void GetResponse::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::kvrpcpb::KeyError& GetResponse::_internal_error() const {
  return *error_;
}
inline const ::kvrpcpb::KeyError& GetResponse::error() const {
  const ::kvrpcpb::KeyError* p = error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.GetResponse.error)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KeyError*>(
      &::kvrpcpb::_KeyError_default_instance_);
}
inline ::kvrpcpb::KeyError* GetResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.GetResponse.error)
  
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::kvrpcpb::KeyError* GetResponse::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::KeyError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.GetResponse.error)
  return error_;
}
inline void GetResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.GetResponse.error)
}

// bytes value = 3;
inline void GetResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetResponse::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.GetResponse.value)
  return value_.GetNoArena();
}
inline void GetResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.GetResponse.value)
}
#if LANG_CXX11
inline void GetResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.GetResponse.value)
}
#endif
inline void GetResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.GetResponse.value)
}
inline void GetResponse::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.GetResponse.value)
}
inline ::std::string* GetResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.GetResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetResponse::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.GetResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.GetResponse.value)
}

// -------------------------------------------------------------------

// ScanRequest

// .kvrpcpb.Context context = 1;
inline bool ScanRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void ScanRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& ScanRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& ScanRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* ScanRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ScanRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* ScanRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanRequest.context)
  return context_;
}
inline void ScanRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ScanRequest.context)
}

// bytes start_key = 2;
inline void ScanRequest::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScanRequest::start_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanRequest.start_key)
  return start_key_.GetNoArena();
}
inline void ScanRequest::set_start_key(const ::std::string& value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.ScanRequest.start_key)
}
#if LANG_CXX11
inline void ScanRequest::set_start_key(::std::string&& value) {
  
  start_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.ScanRequest.start_key)
}
#endif
inline void ScanRequest::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.ScanRequest.start_key)
}
inline void ScanRequest::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.ScanRequest.start_key)
}
inline ::std::string* ScanRequest::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanRequest.start_key)
  return start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScanRequest::release_start_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ScanRequest.start_key)
  
  return start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScanRequest::set_allocated_start_key(::std::string* start_key) {
  if (start_key != NULL) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ScanRequest.start_key)
}

// uint32 limit = 3;
inline void ScanRequest::clear_limit() {
  limit_ = 0u;
}
inline ::google::protobuf::uint32 ScanRequest::limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanRequest.limit)
  return limit_;
}
inline void ScanRequest::set_limit(::google::protobuf::uint32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ScanRequest.limit)
}

// uint64 version = 4;
inline void ScanRequest::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ScanRequest::version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanRequest.version)
  return version_;
}
inline void ScanRequest::set_version(::google::protobuf::uint64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ScanRequest.version)
}

// bool key_only = 5;
inline void ScanRequest::clear_key_only() {
  key_only_ = false;
}
inline bool ScanRequest::key_only() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanRequest.key_only)
  return key_only_;
}
inline void ScanRequest::set_key_only(bool value) {
  
  key_only_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ScanRequest.key_only)
}

// bool reverse = 6;
inline void ScanRequest::clear_reverse() {
  reverse_ = false;
}
inline bool ScanRequest::reverse() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanRequest.reverse)
  return reverse_;
}
inline void ScanRequest::set_reverse(bool value) {
  
  reverse_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ScanRequest.reverse)
}

// -------------------------------------------------------------------

// KvPair

// .kvrpcpb.KeyError error = 1;
inline bool KvPair::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void KvPair::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::kvrpcpb::KeyError& KvPair::_internal_error() const {
  return *error_;
}
inline const ::kvrpcpb::KeyError& KvPair::error() const {
  const ::kvrpcpb::KeyError* p = error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPair.error)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KeyError*>(
      &::kvrpcpb::_KeyError_default_instance_);
}
inline ::kvrpcpb::KeyError* KvPair::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvPair.error)
  
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::kvrpcpb::KeyError* KvPair::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::KeyError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPair.error)
  return error_;
}
inline void KvPair::set_allocated_error(::kvrpcpb::KeyError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPair.error)
}

// bytes key = 2;
inline void KvPair::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvPair::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPair.key)
  return key_.GetNoArena();
}
inline void KvPair::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvPair.key)
}
#if LANG_CXX11
inline void KvPair::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvPair.key)
}
#endif
inline void KvPair::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvPair.key)
}
inline void KvPair::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvPair.key)
}
inline ::std::string* KvPair::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPair.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvPair::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvPair.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvPair::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPair.key)
}

// bytes value = 3;
inline void KvPair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KvPair::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPair.value)
  return value_.GetNoArena();
}
inline void KvPair::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvPair.value)
}
#if LANG_CXX11
inline void KvPair::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KvPair.value)
}
#endif
inline void KvPair::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvPair.value)
}
inline void KvPair::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvPair.value)
}
inline ::std::string* KvPair::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvPair::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KvPair.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvPair::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPair.value)
}

// -------------------------------------------------------------------

// ScanResponse

// .errorpb.Error region_error = 1;
inline bool ScanResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& ScanResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& ScanResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* ScanResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ScanResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* ScanResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanResponse.region_error)
  return region_error_;
}
inline void ScanResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ScanResponse.region_error)
}

// repeated .kvrpcpb.KvPair pairs = 2;
inline int ScanResponse::pairs_size() const {
  return pairs_.size();
}
inline void ScanResponse::clear_pairs() {
  pairs_.Clear();
}
inline ::kvrpcpb::KvPair* ScanResponse::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanResponse.pairs)
  return pairs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
ScanResponse::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.ScanResponse.pairs)
  return &pairs_;
}
inline const ::kvrpcpb::KvPair& ScanResponse::pairs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanResponse.pairs)
  return pairs_.Get(index);
}
inline ::kvrpcpb::KvPair* ScanResponse::add_pairs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.ScanResponse.pairs)
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
ScanResponse::pairs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.ScanResponse.pairs)
  return pairs_;
}

// -------------------------------------------------------------------

// Mutation

// .kvrpcpb.Op op = 1;
inline void Mutation::clear_op() {
  op_ = 0;
}
inline ::kvrpcpb::Op Mutation::op() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Mutation.op)
  return static_cast< ::kvrpcpb::Op >(op_);
}
inline void Mutation::set_op(::kvrpcpb::Op value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Mutation.op)
}

// bytes key = 2;
inline void Mutation::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mutation::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Mutation.key)
  return key_.GetNoArena();
}
inline void Mutation::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Mutation.key)
}
#if LANG_CXX11
inline void Mutation::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Mutation.key)
}
#endif
inline void Mutation::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Mutation.key)
}
inline void Mutation::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Mutation.key)
}
inline ::std::string* Mutation::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Mutation.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mutation::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Mutation.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutation::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Mutation.key)
}

// bytes value = 3;
inline void Mutation::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mutation::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Mutation.value)
  return value_.GetNoArena();
}
inline void Mutation::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Mutation.value)
}
#if LANG_CXX11
inline void Mutation::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.Mutation.value)
}
#endif
inline void Mutation::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Mutation.value)
}
inline void Mutation::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Mutation.value)
}
inline ::std::string* Mutation::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Mutation.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mutation::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.Mutation.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutation::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Mutation.value)
}

// -------------------------------------------------------------------

// PrewriteRequest

// .kvrpcpb.Context context = 1;
inline bool PrewriteRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void PrewriteRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& PrewriteRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& PrewriteRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.PrewriteRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* PrewriteRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.PrewriteRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* PrewriteRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.PrewriteRequest.context)
  return context_;
}
inline void PrewriteRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.PrewriteRequest.context)
}

// repeated .kvrpcpb.Mutation mutations = 2;
inline int PrewriteRequest::mutations_size() const {
  return mutations_.size();
}
inline void PrewriteRequest::clear_mutations() {
  mutations_.Clear();
}
inline ::kvrpcpb::Mutation* PrewriteRequest::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.PrewriteRequest.mutations)
  return mutations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >*
PrewriteRequest::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.PrewriteRequest.mutations)
  return &mutations_;
}
inline const ::kvrpcpb::Mutation& PrewriteRequest::mutations(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.PrewriteRequest.mutations)
  return mutations_.Get(index);
}
inline ::kvrpcpb::Mutation* PrewriteRequest::add_mutations() {
  // @@protoc_insertion_point(field_add:kvrpcpb.PrewriteRequest.mutations)
  return mutations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >&
PrewriteRequest::mutations() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.PrewriteRequest.mutations)
  return mutations_;
}

// bytes primary_lock = 3;
inline void PrewriteRequest::clear_primary_lock() {
  primary_lock_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrewriteRequest::primary_lock() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.PrewriteRequest.primary_lock)
  return primary_lock_.GetNoArena();
}
inline void PrewriteRequest::set_primary_lock(const ::std::string& value) {
  
  primary_lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.PrewriteRequest.primary_lock)
}
#if LANG_CXX11
inline void PrewriteRequest::set_primary_lock(::std::string&& value) {
  
  primary_lock_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.PrewriteRequest.primary_lock)
}
#endif
inline void PrewriteRequest::set_primary_lock(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.PrewriteRequest.primary_lock)
}
inline void PrewriteRequest::set_primary_lock(const void* value, size_t size) {
  
  primary_lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.PrewriteRequest.primary_lock)
}
inline ::std::string* PrewriteRequest::mutable_primary_lock() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.PrewriteRequest.primary_lock)
  return primary_lock_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrewriteRequest::release_primary_lock() {
  // @@protoc_insertion_point(field_release:kvrpcpb.PrewriteRequest.primary_lock)
  
  return primary_lock_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrewriteRequest::set_allocated_primary_lock(::std::string* primary_lock) {
  if (primary_lock != NULL) {
    
  } else {
    
  }
  primary_lock_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary_lock);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.PrewriteRequest.primary_lock)
}

// uint64 start_version = 4;
inline void PrewriteRequest::clear_start_version() {
  start_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PrewriteRequest::start_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.PrewriteRequest.start_version)
  return start_version_;
}
inline void PrewriteRequest::set_start_version(::google::protobuf::uint64 value) {
  
  start_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.PrewriteRequest.start_version)
}

// uint64 lock_ttl = 5;
inline void PrewriteRequest::clear_lock_ttl() {
  lock_ttl_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PrewriteRequest::lock_ttl() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.PrewriteRequest.lock_ttl)
  return lock_ttl_;
}
inline void PrewriteRequest::set_lock_ttl(::google::protobuf::uint64 value) {
  
  lock_ttl_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.PrewriteRequest.lock_ttl)
}

// bool skip_constraint_check = 6;
inline void PrewriteRequest::clear_skip_constraint_check() {
  skip_constraint_check_ = false;
}
inline bool PrewriteRequest::skip_constraint_check() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.PrewriteRequest.skip_constraint_check)
  return skip_constraint_check_;
}
inline void PrewriteRequest::set_skip_constraint_check(bool value) {
  
  skip_constraint_check_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.PrewriteRequest.skip_constraint_check)
}

// -------------------------------------------------------------------

// PrewriteResponse

// .errorpb.Error region_error = 1;
inline bool PrewriteResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& PrewriteResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& PrewriteResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.PrewriteResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* PrewriteResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.PrewriteResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* PrewriteResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.PrewriteResponse.region_error)
  return region_error_;
}
inline void PrewriteResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.PrewriteResponse.region_error)
}

// repeated .kvrpcpb.KeyError errors = 2;
inline int PrewriteResponse::errors_size() const {
  return errors_.size();
}
inline void PrewriteResponse::clear_errors() {
  errors_.Clear();
}
inline ::kvrpcpb::KeyError* PrewriteResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.PrewriteResponse.errors)
  return errors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyError >*
PrewriteResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.PrewriteResponse.errors)
  return &errors_;
}
inline const ::kvrpcpb::KeyError& PrewriteResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.PrewriteResponse.errors)
  return errors_.Get(index);
}
inline ::kvrpcpb::KeyError* PrewriteResponse::add_errors() {
  // @@protoc_insertion_point(field_add:kvrpcpb.PrewriteResponse.errors)
  return errors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyError >&
PrewriteResponse::errors() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.PrewriteResponse.errors)
  return errors_;
}

// -------------------------------------------------------------------

// CommitRequest

// .kvrpcpb.Context context = 1;
inline bool CommitRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void CommitRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& CommitRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& CommitRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.CommitRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* CommitRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.CommitRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* CommitRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CommitRequest.context)
  return context_;
}
inline void CommitRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CommitRequest.context)
}

// uint64 start_version = 2;
inline void CommitRequest::clear_start_version() {
  start_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CommitRequest::start_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CommitRequest.start_version)
  return start_version_;
}
inline void CommitRequest::set_start_version(::google::protobuf::uint64 value) {
  
  start_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CommitRequest.start_version)
}

// repeated bytes keys = 3;
inline int CommitRequest::keys_size() const {
  return keys_.size();
}
inline void CommitRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& CommitRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CommitRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* CommitRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CommitRequest.keys)
  return keys_.Mutable(index);
}
inline void CommitRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.CommitRequest.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CommitRequest::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.CommitRequest.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CommitRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CommitRequest.keys)
}
inline void CommitRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CommitRequest.keys)
}
inline ::std::string* CommitRequest::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:kvrpcpb.CommitRequest.keys)
  return keys_.Add();
}
inline void CommitRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.CommitRequest.keys)
}
#if LANG_CXX11
inline void CommitRequest::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kvrpcpb.CommitRequest.keys)
}
#endif
inline void CommitRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.CommitRequest.keys)
}
inline void CommitRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.CommitRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommitRequest::keys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.CommitRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CommitRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.CommitRequest.keys)
  return &keys_;
}

// uint64 commit_version = 4;
inline void CommitRequest::clear_commit_version() {
  commit_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CommitRequest::commit_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CommitRequest.commit_version)
  return commit_version_;
}
inline void CommitRequest::set_commit_version(::google::protobuf::uint64 value) {
  
  commit_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CommitRequest.commit_version)
}

// -------------------------------------------------------------------

// CommitResponse

// .errorpb.Error region_error = 1;
inline bool CommitResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& CommitResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& CommitResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.CommitResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* CommitResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.CommitResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* CommitResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CommitResponse.region_error)
  return region_error_;
}
inline void CommitResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CommitResponse.region_error)
}

// .kvrpcpb.KeyError error = 2;
inline bool CommitResponse::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void CommitResponse::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::kvrpcpb::KeyError& CommitResponse::_internal_error() const {
  return *error_;
}
inline const ::kvrpcpb::KeyError& CommitResponse::error() const {
  const ::kvrpcpb::KeyError* p = error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.CommitResponse.error)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KeyError*>(
      &::kvrpcpb::_KeyError_default_instance_);
}
inline ::kvrpcpb::KeyError* CommitResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.CommitResponse.error)
  
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::kvrpcpb::KeyError* CommitResponse::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::KeyError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CommitResponse.error)
  return error_;
}
inline void CommitResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CommitResponse.error)
}

// -------------------------------------------------------------------

// ImportRequest

// repeated .kvrpcpb.Mutation mutations = 1;
inline int ImportRequest::mutations_size() const {
  return mutations_.size();
}
inline void ImportRequest::clear_mutations() {
  mutations_.Clear();
}
inline ::kvrpcpb::Mutation* ImportRequest::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ImportRequest.mutations)
  return mutations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >*
ImportRequest::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.ImportRequest.mutations)
  return &mutations_;
}
inline const ::kvrpcpb::Mutation& ImportRequest::mutations(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ImportRequest.mutations)
  return mutations_.Get(index);
}
inline ::kvrpcpb::Mutation* ImportRequest::add_mutations() {
  // @@protoc_insertion_point(field_add:kvrpcpb.ImportRequest.mutations)
  return mutations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >&
ImportRequest::mutations() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.ImportRequest.mutations)
  return mutations_;
}

// uint64 commit_version = 2;
inline void ImportRequest::clear_commit_version() {
  commit_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ImportRequest::commit_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ImportRequest.commit_version)
  return commit_version_;
}
inline void ImportRequest::set_commit_version(::google::protobuf::uint64 value) {
  
  commit_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ImportRequest.commit_version)
}

// -------------------------------------------------------------------

// ImportResponse

// .errorpb.Error region_error = 1;
inline bool ImportResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& ImportResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& ImportResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ImportResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* ImportResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ImportResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* ImportResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ImportResponse.region_error)
  return region_error_;
}
inline void ImportResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ImportResponse.region_error)
}

// string error = 2;
inline void ImportResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImportResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ImportResponse.error)
  return error_.GetNoArena();
}
inline void ImportResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.ImportResponse.error)
}
#if LANG_CXX11
inline void ImportResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.ImportResponse.error)
}
#endif
inline void ImportResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.ImportResponse.error)
}
inline void ImportResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.ImportResponse.error)
}
inline ::std::string* ImportResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ImportResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImportResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ImportResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImportResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ImportResponse.error)
}

// -------------------------------------------------------------------

// BatchRollbackRequest

// .kvrpcpb.Context context = 1;
inline bool BatchRollbackRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void BatchRollbackRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& BatchRollbackRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& BatchRollbackRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchRollbackRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* BatchRollbackRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.BatchRollbackRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* BatchRollbackRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchRollbackRequest.context)
  return context_;
}
inline void BatchRollbackRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.BatchRollbackRequest.context)
}

// uint64 start_version = 2;
inline void BatchRollbackRequest::clear_start_version() {
  start_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BatchRollbackRequest::start_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchRollbackRequest.start_version)
  return start_version_;
}
inline void BatchRollbackRequest::set_start_version(::google::protobuf::uint64 value) {
  
  start_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.BatchRollbackRequest.start_version)
}

// repeated bytes keys = 3;
inline int BatchRollbackRequest::keys_size() const {
  return keys_.size();
}
inline void BatchRollbackRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& BatchRollbackRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchRollbackRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* BatchRollbackRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchRollbackRequest.keys)
  return keys_.Mutable(index);
}
inline void BatchRollbackRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.BatchRollbackRequest.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BatchRollbackRequest::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.BatchRollbackRequest.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BatchRollbackRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.BatchRollbackRequest.keys)
}
inline void BatchRollbackRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.BatchRollbackRequest.keys)
}
inline ::std::string* BatchRollbackRequest::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:kvrpcpb.BatchRollbackRequest.keys)
  return keys_.Add();
}
inline void BatchRollbackRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.BatchRollbackRequest.keys)
}
#if LANG_CXX11
inline void BatchRollbackRequest::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kvrpcpb.BatchRollbackRequest.keys)
}
#endif
inline void BatchRollbackRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.BatchRollbackRequest.keys)
}
inline void BatchRollbackRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.BatchRollbackRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatchRollbackRequest::keys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.BatchRollbackRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatchRollbackRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.BatchRollbackRequest.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// BatchRollbackResponse

// .errorpb.Error region_error = 1;
inline bool BatchRollbackResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& BatchRollbackResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& BatchRollbackResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchRollbackResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* BatchRollbackResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.BatchRollbackResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* BatchRollbackResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchRollbackResponse.region_error)
  return region_error_;
}
inline void BatchRollbackResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.BatchRollbackResponse.region_error)
}

// .kvrpcpb.KeyError error = 2;
inline bool BatchRollbackResponse::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void BatchRollbackResponse::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::kvrpcpb::KeyError& BatchRollbackResponse::_internal_error() const {
  return *error_;
}
inline const ::kvrpcpb::KeyError& BatchRollbackResponse::error() const {
  const ::kvrpcpb::KeyError* p = error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchRollbackResponse.error)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KeyError*>(
      &::kvrpcpb::_KeyError_default_instance_);
}
inline ::kvrpcpb::KeyError* BatchRollbackResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.BatchRollbackResponse.error)
  
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::kvrpcpb::KeyError* BatchRollbackResponse::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::KeyError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchRollbackResponse.error)
  return error_;
}
inline void BatchRollbackResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.BatchRollbackResponse.error)
}

// -------------------------------------------------------------------

// CleanupRequest

// .kvrpcpb.Context context = 1;
inline bool CleanupRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void CleanupRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& CleanupRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& CleanupRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.CleanupRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* CleanupRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.CleanupRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* CleanupRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CleanupRequest.context)
  return context_;
}
inline void CleanupRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CleanupRequest.context)
}

// bytes key = 2;
inline void CleanupRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CleanupRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CleanupRequest.key)
  return key_.GetNoArena();
}
inline void CleanupRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CleanupRequest.key)
}
#if LANG_CXX11
inline void CleanupRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.CleanupRequest.key)
}
#endif
inline void CleanupRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CleanupRequest.key)
}
inline void CleanupRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CleanupRequest.key)
}
inline ::std::string* CleanupRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CleanupRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CleanupRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.CleanupRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CleanupRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CleanupRequest.key)
}

// uint64 start_version = 3;
inline void CleanupRequest::clear_start_version() {
  start_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CleanupRequest::start_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CleanupRequest.start_version)
  return start_version_;
}
inline void CleanupRequest::set_start_version(::google::protobuf::uint64 value) {
  
  start_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CleanupRequest.start_version)
}

// -------------------------------------------------------------------

// CleanupResponse

// .errorpb.Error region_error = 1;
inline bool CleanupResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& CleanupResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& CleanupResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.CleanupResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* CleanupResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.CleanupResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* CleanupResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CleanupResponse.region_error)
  return region_error_;
}
inline void CleanupResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CleanupResponse.region_error)
}

// .kvrpcpb.KeyError error = 2;
inline bool CleanupResponse::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void CleanupResponse::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::kvrpcpb::KeyError& CleanupResponse::_internal_error() const {
  return *error_;
}
inline const ::kvrpcpb::KeyError& CleanupResponse::error() const {
  const ::kvrpcpb::KeyError* p = error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.CleanupResponse.error)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KeyError*>(
      &::kvrpcpb::_KeyError_default_instance_);
}
inline ::kvrpcpb::KeyError* CleanupResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.CleanupResponse.error)
  
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::kvrpcpb::KeyError* CleanupResponse::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::KeyError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CleanupResponse.error)
  return error_;
}
inline void CleanupResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CleanupResponse.error)
}

// uint64 commit_version = 3;
inline void CleanupResponse::clear_commit_version() {
  commit_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CleanupResponse::commit_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CleanupResponse.commit_version)
  return commit_version_;
}
inline void CleanupResponse::set_commit_version(::google::protobuf::uint64 value) {
  
  commit_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CleanupResponse.commit_version)
}

// -------------------------------------------------------------------

// BatchGetRequest

// .kvrpcpb.Context context = 1;
inline bool BatchGetRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void BatchGetRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& BatchGetRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& BatchGetRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchGetRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* BatchGetRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.BatchGetRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* BatchGetRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchGetRequest.context)
  return context_;
}
inline void BatchGetRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.BatchGetRequest.context)
}

// repeated bytes keys = 2;
inline int BatchGetRequest::keys_size() const {
  return keys_.size();
}
inline void BatchGetRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& BatchGetRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchGetRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* BatchGetRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchGetRequest.keys)
  return keys_.Mutable(index);
}
inline void BatchGetRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.BatchGetRequest.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BatchGetRequest::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.BatchGetRequest.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BatchGetRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.BatchGetRequest.keys)
}
inline void BatchGetRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.BatchGetRequest.keys)
}
inline ::std::string* BatchGetRequest::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:kvrpcpb.BatchGetRequest.keys)
  return keys_.Add();
}
inline void BatchGetRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.BatchGetRequest.keys)
}
#if LANG_CXX11
inline void BatchGetRequest::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kvrpcpb.BatchGetRequest.keys)
}
#endif
inline void BatchGetRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.BatchGetRequest.keys)
}
inline void BatchGetRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.BatchGetRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BatchGetRequest::keys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.BatchGetRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BatchGetRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.BatchGetRequest.keys)
  return &keys_;
}

// uint64 version = 3;
inline void BatchGetRequest::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BatchGetRequest::version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchGetRequest.version)
  return version_;
}
inline void BatchGetRequest::set_version(::google::protobuf::uint64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.BatchGetRequest.version)
}

// -------------------------------------------------------------------

// BatchGetResponse

// .errorpb.Error region_error = 1;
inline bool BatchGetResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& BatchGetResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& BatchGetResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchGetResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* BatchGetResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.BatchGetResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* BatchGetResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchGetResponse.region_error)
  return region_error_;
}
inline void BatchGetResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.BatchGetResponse.region_error)
}

// repeated .kvrpcpb.KvPair pairs = 2;
inline int BatchGetResponse::pairs_size() const {
  return pairs_.size();
}
inline void BatchGetResponse::clear_pairs() {
  pairs_.Clear();
}
inline ::kvrpcpb::KvPair* BatchGetResponse::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.BatchGetResponse.pairs)
  return pairs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
BatchGetResponse::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.BatchGetResponse.pairs)
  return &pairs_;
}
inline const ::kvrpcpb::KvPair& BatchGetResponse::pairs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.BatchGetResponse.pairs)
  return pairs_.Get(index);
}
inline ::kvrpcpb::KvPair* BatchGetResponse::add_pairs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.BatchGetResponse.pairs)
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
BatchGetResponse::pairs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.BatchGetResponse.pairs)
  return pairs_;
}

// -------------------------------------------------------------------

// ScanLockRequest

// .kvrpcpb.Context context = 1;
inline bool ScanLockRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void ScanLockRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& ScanLockRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& ScanLockRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanLockRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* ScanLockRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ScanLockRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* ScanLockRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanLockRequest.context)
  return context_;
}
inline void ScanLockRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ScanLockRequest.context)
}

// uint64 max_version = 2;
inline void ScanLockRequest::clear_max_version() {
  max_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ScanLockRequest::max_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanLockRequest.max_version)
  return max_version_;
}
inline void ScanLockRequest::set_max_version(::google::protobuf::uint64 value) {
  
  max_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ScanLockRequest.max_version)
}

// bytes start_key = 3;
inline void ScanLockRequest::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ScanLockRequest::start_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanLockRequest.start_key)
  return start_key_.GetNoArena();
}
inline void ScanLockRequest::set_start_key(const ::std::string& value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.ScanLockRequest.start_key)
}
#if LANG_CXX11
inline void ScanLockRequest::set_start_key(::std::string&& value) {
  
  start_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.ScanLockRequest.start_key)
}
#endif
inline void ScanLockRequest::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.ScanLockRequest.start_key)
}
inline void ScanLockRequest::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.ScanLockRequest.start_key)
}
inline ::std::string* ScanLockRequest::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanLockRequest.start_key)
  return start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ScanLockRequest::release_start_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ScanLockRequest.start_key)
  
  return start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ScanLockRequest::set_allocated_start_key(::std::string* start_key) {
  if (start_key != NULL) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ScanLockRequest.start_key)
}

// uint32 limit = 4;
inline void ScanLockRequest::clear_limit() {
  limit_ = 0u;
}
inline ::google::protobuf::uint32 ScanLockRequest::limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanLockRequest.limit)
  return limit_;
}
inline void ScanLockRequest::set_limit(::google::protobuf::uint32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ScanLockRequest.limit)
}

// -------------------------------------------------------------------

// ScanLockResponse

// .errorpb.Error region_error = 1;
inline bool ScanLockResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& ScanLockResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& ScanLockResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanLockResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* ScanLockResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ScanLockResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* ScanLockResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanLockResponse.region_error)
  return region_error_;
}
inline void ScanLockResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ScanLockResponse.region_error)
}

// .kvrpcpb.KeyError error = 2;
inline bool ScanLockResponse::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void ScanLockResponse::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::kvrpcpb::KeyError& ScanLockResponse::_internal_error() const {
  return *error_;
}
inline const ::kvrpcpb::KeyError& ScanLockResponse::error() const {
  const ::kvrpcpb::KeyError* p = error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanLockResponse.error)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KeyError*>(
      &::kvrpcpb::_KeyError_default_instance_);
}
inline ::kvrpcpb::KeyError* ScanLockResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ScanLockResponse.error)
  
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::kvrpcpb::KeyError* ScanLockResponse::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::KeyError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanLockResponse.error)
  return error_;
}
inline void ScanLockResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ScanLockResponse.error)
}

// repeated .kvrpcpb.LockInfo locks = 3;
inline int ScanLockResponse::locks_size() const {
  return locks_.size();
}
inline void ScanLockResponse::clear_locks() {
  locks_.Clear();
}
inline ::kvrpcpb::LockInfo* ScanLockResponse::mutable_locks(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ScanLockResponse.locks)
  return locks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >*
ScanLockResponse::mutable_locks() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.ScanLockResponse.locks)
  return &locks_;
}
inline const ::kvrpcpb::LockInfo& ScanLockResponse::locks(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ScanLockResponse.locks)
  return locks_.Get(index);
}
inline ::kvrpcpb::LockInfo* ScanLockResponse::add_locks() {
  // @@protoc_insertion_point(field_add:kvrpcpb.ScanLockResponse.locks)
  return locks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >&
ScanLockResponse::locks() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.ScanLockResponse.locks)
  return locks_;
}

// -------------------------------------------------------------------

// TxnInfo

// uint64 txn = 1;
inline void TxnInfo::clear_txn() {
  txn_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxnInfo::txn() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.TxnInfo.txn)
  return txn_;
}
inline void TxnInfo::set_txn(::google::protobuf::uint64 value) {
  
  txn_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.TxnInfo.txn)
}

// uint64 status = 2;
inline void TxnInfo::clear_status() {
  status_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxnInfo::status() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.TxnInfo.status)
  return status_;
}
inline void TxnInfo::set_status(::google::protobuf::uint64 value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.TxnInfo.status)
}

// -------------------------------------------------------------------

// ResolveLockRequest

// .kvrpcpb.Context context = 1;
inline bool ResolveLockRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void ResolveLockRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& ResolveLockRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& ResolveLockRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ResolveLockRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* ResolveLockRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ResolveLockRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* ResolveLockRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ResolveLockRequest.context)
  return context_;
}
inline void ResolveLockRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ResolveLockRequest.context)
}

// uint64 start_version = 2;
inline void ResolveLockRequest::clear_start_version() {
  start_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResolveLockRequest::start_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ResolveLockRequest.start_version)
  return start_version_;
}
inline void ResolveLockRequest::set_start_version(::google::protobuf::uint64 value) {
  
  start_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ResolveLockRequest.start_version)
}

// uint64 commit_version = 3;
inline void ResolveLockRequest::clear_commit_version() {
  commit_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResolveLockRequest::commit_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ResolveLockRequest.commit_version)
  return commit_version_;
}
inline void ResolveLockRequest::set_commit_version(::google::protobuf::uint64 value) {
  
  commit_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.ResolveLockRequest.commit_version)
}

// repeated .kvrpcpb.TxnInfo txn_infos = 4;
inline int ResolveLockRequest::txn_infos_size() const {
  return txn_infos_.size();
}
inline void ResolveLockRequest::clear_txn_infos() {
  txn_infos_.Clear();
}
inline ::kvrpcpb::TxnInfo* ResolveLockRequest::mutable_txn_infos(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ResolveLockRequest.txn_infos)
  return txn_infos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::TxnInfo >*
ResolveLockRequest::mutable_txn_infos() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.ResolveLockRequest.txn_infos)
  return &txn_infos_;
}
inline const ::kvrpcpb::TxnInfo& ResolveLockRequest::txn_infos(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.ResolveLockRequest.txn_infos)
  return txn_infos_.Get(index);
}
inline ::kvrpcpb::TxnInfo* ResolveLockRequest::add_txn_infos() {
  // @@protoc_insertion_point(field_add:kvrpcpb.ResolveLockRequest.txn_infos)
  return txn_infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::TxnInfo >&
ResolveLockRequest::txn_infos() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.ResolveLockRequest.txn_infos)
  return txn_infos_;
}

// -------------------------------------------------------------------

// ResolveLockResponse

// .errorpb.Error region_error = 1;
inline bool ResolveLockResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& ResolveLockResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& ResolveLockResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ResolveLockResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* ResolveLockResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ResolveLockResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* ResolveLockResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ResolveLockResponse.region_error)
  return region_error_;
}
inline void ResolveLockResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ResolveLockResponse.region_error)
}

// .kvrpcpb.KeyError error = 2;
inline bool ResolveLockResponse::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void ResolveLockResponse::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::kvrpcpb::KeyError& ResolveLockResponse::_internal_error() const {
  return *error_;
}
inline const ::kvrpcpb::KeyError& ResolveLockResponse::error() const {
  const ::kvrpcpb::KeyError* p = error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.ResolveLockResponse.error)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KeyError*>(
      &::kvrpcpb::_KeyError_default_instance_);
}
inline ::kvrpcpb::KeyError* ResolveLockResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.ResolveLockResponse.error)
  
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::kvrpcpb::KeyError* ResolveLockResponse::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::KeyError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.ResolveLockResponse.error)
  return error_;
}
inline void ResolveLockResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.ResolveLockResponse.error)
}

// -------------------------------------------------------------------

// GCRequest

// .kvrpcpb.Context context = 1;
inline bool GCRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void GCRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& GCRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& GCRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.GCRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* GCRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.GCRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* GCRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.GCRequest.context)
  return context_;
}
inline void GCRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.GCRequest.context)
}

// uint64 safe_point = 2;
inline void GCRequest::clear_safe_point() {
  safe_point_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GCRequest::safe_point() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.GCRequest.safe_point)
  return safe_point_;
}
inline void GCRequest::set_safe_point(::google::protobuf::uint64 value) {
  
  safe_point_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.GCRequest.safe_point)
}

// -------------------------------------------------------------------

// GCResponse

// .errorpb.Error region_error = 1;
inline bool GCResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& GCResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& GCResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.GCResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* GCResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.GCResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* GCResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.GCResponse.region_error)
  return region_error_;
}
inline void GCResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.GCResponse.region_error)
}

// .kvrpcpb.KeyError error = 2;
inline bool GCResponse::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void GCResponse::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::kvrpcpb::KeyError& GCResponse::_internal_error() const {
  return *error_;
}
inline const ::kvrpcpb::KeyError& GCResponse::error() const {
  const ::kvrpcpb::KeyError* p = error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.GCResponse.error)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::KeyError*>(
      &::kvrpcpb::_KeyError_default_instance_);
}
inline ::kvrpcpb::KeyError* GCResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.GCResponse.error)
  
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::kvrpcpb::KeyError* GCResponse::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::KeyError>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.GCResponse.error)
  return error_;
}
inline void GCResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.GCResponse.error)
}

// -------------------------------------------------------------------

// RawGetRequest

// .kvrpcpb.Context context = 1;
inline bool RawGetRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void RawGetRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& RawGetRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& RawGetRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawGetRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* RawGetRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawGetRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* RawGetRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawGetRequest.context)
  return context_;
}
inline void RawGetRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawGetRequest.context)
}

// bytes key = 2;
inline void RawGetRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawGetRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawGetRequest.key)
  return key_.GetNoArena();
}
inline void RawGetRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawGetRequest.key)
}
#if LANG_CXX11
inline void RawGetRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawGetRequest.key)
}
#endif
inline void RawGetRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawGetRequest.key)
}
inline void RawGetRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawGetRequest.key)
}
inline ::std::string* RawGetRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawGetRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawGetRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawGetRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawGetRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawGetRequest.key)
}

// string cf = 3;
inline void RawGetRequest::clear_cf() {
  cf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawGetRequest::cf() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawGetRequest.cf)
  return cf_.GetNoArena();
}
inline void RawGetRequest::set_cf(const ::std::string& value) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawGetRequest.cf)
}
#if LANG_CXX11
inline void RawGetRequest::set_cf(::std::string&& value) {
  
  cf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawGetRequest.cf)
}
#endif
inline void RawGetRequest::set_cf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawGetRequest.cf)
}
inline void RawGetRequest::set_cf(const char* value, size_t size) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawGetRequest.cf)
}
inline ::std::string* RawGetRequest::mutable_cf() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawGetRequest.cf)
  return cf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawGetRequest::release_cf() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawGetRequest.cf)
  
  return cf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawGetRequest::set_allocated_cf(::std::string* cf) {
  if (cf != NULL) {
    
  } else {
    
  }
  cf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cf);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawGetRequest.cf)
}

// -------------------------------------------------------------------

// RawGetResponse

// .errorpb.Error region_error = 1;
inline bool RawGetResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& RawGetResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& RawGetResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawGetResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* RawGetResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawGetResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* RawGetResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawGetResponse.region_error)
  return region_error_;
}
inline void RawGetResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawGetResponse.region_error)
}

// string error = 2;
inline void RawGetResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawGetResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawGetResponse.error)
  return error_.GetNoArena();
}
inline void RawGetResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawGetResponse.error)
}
#if LANG_CXX11
inline void RawGetResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawGetResponse.error)
}
#endif
inline void RawGetResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawGetResponse.error)
}
inline void RawGetResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawGetResponse.error)
}
inline ::std::string* RawGetResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawGetResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawGetResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawGetResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawGetResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawGetResponse.error)
}

// bytes value = 3;
inline void RawGetResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawGetResponse::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawGetResponse.value)
  return value_.GetNoArena();
}
inline void RawGetResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawGetResponse.value)
}
#if LANG_CXX11
inline void RawGetResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawGetResponse.value)
}
#endif
inline void RawGetResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawGetResponse.value)
}
inline void RawGetResponse::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawGetResponse.value)
}
inline ::std::string* RawGetResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawGetResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawGetResponse::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawGetResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawGetResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawGetResponse.value)
}

// -------------------------------------------------------------------

// RawPutRequest

// .kvrpcpb.Context context = 1;
inline bool RawPutRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void RawPutRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& RawPutRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& RawPutRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawPutRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* RawPutRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawPutRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* RawPutRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawPutRequest.context)
  return context_;
}
inline void RawPutRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawPutRequest.context)
}

// bytes key = 2;
inline void RawPutRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawPutRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawPutRequest.key)
  return key_.GetNoArena();
}
inline void RawPutRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawPutRequest.key)
}
#if LANG_CXX11
inline void RawPutRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawPutRequest.key)
}
#endif
inline void RawPutRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawPutRequest.key)
}
inline void RawPutRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawPutRequest.key)
}
inline ::std::string* RawPutRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawPutRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawPutRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawPutRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawPutRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawPutRequest.key)
}

// bytes value = 3;
inline void RawPutRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawPutRequest::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawPutRequest.value)
  return value_.GetNoArena();
}
inline void RawPutRequest::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawPutRequest.value)
}
#if LANG_CXX11
inline void RawPutRequest::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawPutRequest.value)
}
#endif
inline void RawPutRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawPutRequest.value)
}
inline void RawPutRequest::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawPutRequest.value)
}
inline ::std::string* RawPutRequest::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawPutRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawPutRequest::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawPutRequest.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawPutRequest::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawPutRequest.value)
}

// string cf = 4;
inline void RawPutRequest::clear_cf() {
  cf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawPutRequest::cf() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawPutRequest.cf)
  return cf_.GetNoArena();
}
inline void RawPutRequest::set_cf(const ::std::string& value) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawPutRequest.cf)
}
#if LANG_CXX11
inline void RawPutRequest::set_cf(::std::string&& value) {
  
  cf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawPutRequest.cf)
}
#endif
inline void RawPutRequest::set_cf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawPutRequest.cf)
}
inline void RawPutRequest::set_cf(const char* value, size_t size) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawPutRequest.cf)
}
inline ::std::string* RawPutRequest::mutable_cf() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawPutRequest.cf)
  return cf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawPutRequest::release_cf() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawPutRequest.cf)
  
  return cf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawPutRequest::set_allocated_cf(::std::string* cf) {
  if (cf != NULL) {
    
  } else {
    
  }
  cf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cf);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawPutRequest.cf)
}

// -------------------------------------------------------------------

// RawPutResponse

// .errorpb.Error region_error = 1;
inline bool RawPutResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& RawPutResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& RawPutResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawPutResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* RawPutResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawPutResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* RawPutResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawPutResponse.region_error)
  return region_error_;
}
inline void RawPutResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawPutResponse.region_error)
}

// string error = 2;
inline void RawPutResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawPutResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawPutResponse.error)
  return error_.GetNoArena();
}
inline void RawPutResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawPutResponse.error)
}
#if LANG_CXX11
inline void RawPutResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawPutResponse.error)
}
#endif
inline void RawPutResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawPutResponse.error)
}
inline void RawPutResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawPutResponse.error)
}
inline ::std::string* RawPutResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawPutResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawPutResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawPutResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawPutResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawPutResponse.error)
}

// -------------------------------------------------------------------

// RawBatchPutRequest

// .kvrpcpb.Context context = 1;
inline bool RawBatchPutRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void RawBatchPutRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& RawBatchPutRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& RawBatchPutRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchPutRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* RawBatchPutRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchPutRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* RawBatchPutRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchPutRequest.context)
  return context_;
}
inline void RawBatchPutRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchPutRequest.context)
}

// repeated .kvrpcpb.KvPair pairs = 2;
inline int RawBatchPutRequest::pairs_size() const {
  return pairs_.size();
}
inline void RawBatchPutRequest::clear_pairs() {
  pairs_.Clear();
}
inline ::kvrpcpb::KvPair* RawBatchPutRequest::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchPutRequest.pairs)
  return pairs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
RawBatchPutRequest::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.RawBatchPutRequest.pairs)
  return &pairs_;
}
inline const ::kvrpcpb::KvPair& RawBatchPutRequest::pairs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchPutRequest.pairs)
  return pairs_.Get(index);
}
inline ::kvrpcpb::KvPair* RawBatchPutRequest::add_pairs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.RawBatchPutRequest.pairs)
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
RawBatchPutRequest::pairs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.RawBatchPutRequest.pairs)
  return pairs_;
}

// string cf = 3;
inline void RawBatchPutRequest::clear_cf() {
  cf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawBatchPutRequest::cf() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchPutRequest.cf)
  return cf_.GetNoArena();
}
inline void RawBatchPutRequest::set_cf(const ::std::string& value) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchPutRequest.cf)
}
#if LANG_CXX11
inline void RawBatchPutRequest::set_cf(::std::string&& value) {
  
  cf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawBatchPutRequest.cf)
}
#endif
inline void RawBatchPutRequest::set_cf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawBatchPutRequest.cf)
}
inline void RawBatchPutRequest::set_cf(const char* value, size_t size) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawBatchPutRequest.cf)
}
inline ::std::string* RawBatchPutRequest::mutable_cf() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchPutRequest.cf)
  return cf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawBatchPutRequest::release_cf() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchPutRequest.cf)
  
  return cf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawBatchPutRequest::set_allocated_cf(::std::string* cf) {
  if (cf != NULL) {
    
  } else {
    
  }
  cf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cf);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchPutRequest.cf)
}

// -------------------------------------------------------------------

// RawBatchPutResponse

// .errorpb.Error region_error = 1;
inline bool RawBatchPutResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& RawBatchPutResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& RawBatchPutResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchPutResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* RawBatchPutResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchPutResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* RawBatchPutResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchPutResponse.region_error)
  return region_error_;
}
inline void RawBatchPutResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchPutResponse.region_error)
}

// string error = 2;
inline void RawBatchPutResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawBatchPutResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchPutResponse.error)
  return error_.GetNoArena();
}
inline void RawBatchPutResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchPutResponse.error)
}
#if LANG_CXX11
inline void RawBatchPutResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawBatchPutResponse.error)
}
#endif
inline void RawBatchPutResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawBatchPutResponse.error)
}
inline void RawBatchPutResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawBatchPutResponse.error)
}
inline ::std::string* RawBatchPutResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchPutResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawBatchPutResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchPutResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawBatchPutResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchPutResponse.error)
}

// -------------------------------------------------------------------

// RawBatchGetRequest

// .kvrpcpb.Context context = 1;
inline bool RawBatchGetRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void RawBatchGetRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& RawBatchGetRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& RawBatchGetRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchGetRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* RawBatchGetRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchGetRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* RawBatchGetRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchGetRequest.context)
  return context_;
}
inline void RawBatchGetRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchGetRequest.context)
}

// repeated bytes keys = 2;
inline int RawBatchGetRequest::keys_size() const {
  return keys_.size();
}
inline void RawBatchGetRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RawBatchGetRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchGetRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* RawBatchGetRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchGetRequest.keys)
  return keys_.Mutable(index);
}
inline void RawBatchGetRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchGetRequest.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RawBatchGetRequest::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchGetRequest.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RawBatchGetRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawBatchGetRequest.keys)
}
inline void RawBatchGetRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawBatchGetRequest.keys)
}
inline ::std::string* RawBatchGetRequest::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:kvrpcpb.RawBatchGetRequest.keys)
  return keys_.Add();
}
inline void RawBatchGetRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.RawBatchGetRequest.keys)
}
#if LANG_CXX11
inline void RawBatchGetRequest::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kvrpcpb.RawBatchGetRequest.keys)
}
#endif
inline void RawBatchGetRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.RawBatchGetRequest.keys)
}
inline void RawBatchGetRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.RawBatchGetRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RawBatchGetRequest::keys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.RawBatchGetRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RawBatchGetRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.RawBatchGetRequest.keys)
  return &keys_;
}

// string cf = 3;
inline void RawBatchGetRequest::clear_cf() {
  cf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawBatchGetRequest::cf() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchGetRequest.cf)
  return cf_.GetNoArena();
}
inline void RawBatchGetRequest::set_cf(const ::std::string& value) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchGetRequest.cf)
}
#if LANG_CXX11
inline void RawBatchGetRequest::set_cf(::std::string&& value) {
  
  cf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawBatchGetRequest.cf)
}
#endif
inline void RawBatchGetRequest::set_cf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawBatchGetRequest.cf)
}
inline void RawBatchGetRequest::set_cf(const char* value, size_t size) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawBatchGetRequest.cf)
}
inline ::std::string* RawBatchGetRequest::mutable_cf() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchGetRequest.cf)
  return cf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawBatchGetRequest::release_cf() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchGetRequest.cf)
  
  return cf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawBatchGetRequest::set_allocated_cf(::std::string* cf) {
  if (cf != NULL) {
    
  } else {
    
  }
  cf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cf);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchGetRequest.cf)
}

// -------------------------------------------------------------------

// RawBatchGetResponse

// .errorpb.Error region_error = 1;
inline bool RawBatchGetResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& RawBatchGetResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& RawBatchGetResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchGetResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* RawBatchGetResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchGetResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* RawBatchGetResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchGetResponse.region_error)
  return region_error_;
}
inline void RawBatchGetResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchGetResponse.region_error)
}

// repeated .kvrpcpb.KvPair pairs = 2;
inline int RawBatchGetResponse::pairs_size() const {
  return pairs_.size();
}
inline void RawBatchGetResponse::clear_pairs() {
  pairs_.Clear();
}
inline ::kvrpcpb::KvPair* RawBatchGetResponse::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchGetResponse.pairs)
  return pairs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
RawBatchGetResponse::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.RawBatchGetResponse.pairs)
  return &pairs_;
}
inline const ::kvrpcpb::KvPair& RawBatchGetResponse::pairs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchGetResponse.pairs)
  return pairs_.Get(index);
}
inline ::kvrpcpb::KvPair* RawBatchGetResponse::add_pairs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.RawBatchGetResponse.pairs)
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
RawBatchGetResponse::pairs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.RawBatchGetResponse.pairs)
  return pairs_;
}

// -------------------------------------------------------------------

// RawDeleteRequest

// .kvrpcpb.Context context = 1;
inline bool RawDeleteRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void RawDeleteRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& RawDeleteRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& RawDeleteRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* RawDeleteRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* RawDeleteRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteRequest.context)
  return context_;
}
inline void RawDeleteRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteRequest.context)
}

// bytes key = 2;
inline void RawDeleteRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawDeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteRequest.key)
  return key_.GetNoArena();
}
inline void RawDeleteRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawDeleteRequest.key)
}
#if LANG_CXX11
inline void RawDeleteRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawDeleteRequest.key)
}
#endif
inline void RawDeleteRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawDeleteRequest.key)
}
inline void RawDeleteRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawDeleteRequest.key)
}
inline ::std::string* RawDeleteRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawDeleteRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawDeleteRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteRequest.key)
}

// string cf = 3;
inline void RawDeleteRequest::clear_cf() {
  cf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawDeleteRequest::cf() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteRequest.cf)
  return cf_.GetNoArena();
}
inline void RawDeleteRequest::set_cf(const ::std::string& value) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawDeleteRequest.cf)
}
#if LANG_CXX11
inline void RawDeleteRequest::set_cf(::std::string&& value) {
  
  cf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawDeleteRequest.cf)
}
#endif
inline void RawDeleteRequest::set_cf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawDeleteRequest.cf)
}
inline void RawDeleteRequest::set_cf(const char* value, size_t size) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawDeleteRequest.cf)
}
inline ::std::string* RawDeleteRequest::mutable_cf() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteRequest.cf)
  return cf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawDeleteRequest::release_cf() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteRequest.cf)
  
  return cf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawDeleteRequest::set_allocated_cf(::std::string* cf) {
  if (cf != NULL) {
    
  } else {
    
  }
  cf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cf);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteRequest.cf)
}

// -------------------------------------------------------------------

// RawDeleteResponse

// .errorpb.Error region_error = 1;
inline bool RawDeleteResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& RawDeleteResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& RawDeleteResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* RawDeleteResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* RawDeleteResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteResponse.region_error)
  return region_error_;
}
inline void RawDeleteResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteResponse.region_error)
}

// string error = 2;
inline void RawDeleteResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawDeleteResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteResponse.error)
  return error_.GetNoArena();
}
inline void RawDeleteResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawDeleteResponse.error)
}
#if LANG_CXX11
inline void RawDeleteResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawDeleteResponse.error)
}
#endif
inline void RawDeleteResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawDeleteResponse.error)
}
inline void RawDeleteResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawDeleteResponse.error)
}
inline ::std::string* RawDeleteResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawDeleteResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawDeleteResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteResponse.error)
}

// -------------------------------------------------------------------

// RawBatchDeleteRequest

// .kvrpcpb.Context context = 1;
inline bool RawBatchDeleteRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void RawBatchDeleteRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& RawBatchDeleteRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& RawBatchDeleteRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchDeleteRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* RawBatchDeleteRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchDeleteRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* RawBatchDeleteRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchDeleteRequest.context)
  return context_;
}
inline void RawBatchDeleteRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchDeleteRequest.context)
}

// repeated bytes keys = 2;
inline int RawBatchDeleteRequest::keys_size() const {
  return keys_.size();
}
inline void RawBatchDeleteRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& RawBatchDeleteRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchDeleteRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* RawBatchDeleteRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchDeleteRequest.keys)
  return keys_.Mutable(index);
}
inline void RawBatchDeleteRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchDeleteRequest.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RawBatchDeleteRequest::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchDeleteRequest.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RawBatchDeleteRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawBatchDeleteRequest.keys)
}
inline void RawBatchDeleteRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawBatchDeleteRequest.keys)
}
inline ::std::string* RawBatchDeleteRequest::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:kvrpcpb.RawBatchDeleteRequest.keys)
  return keys_.Add();
}
inline void RawBatchDeleteRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.RawBatchDeleteRequest.keys)
}
#if LANG_CXX11
inline void RawBatchDeleteRequest::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:kvrpcpb.RawBatchDeleteRequest.keys)
}
#endif
inline void RawBatchDeleteRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.RawBatchDeleteRequest.keys)
}
inline void RawBatchDeleteRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.RawBatchDeleteRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RawBatchDeleteRequest::keys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.RawBatchDeleteRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RawBatchDeleteRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.RawBatchDeleteRequest.keys)
  return &keys_;
}

// string cf = 3;
inline void RawBatchDeleteRequest::clear_cf() {
  cf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawBatchDeleteRequest::cf() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchDeleteRequest.cf)
  return cf_.GetNoArena();
}
inline void RawBatchDeleteRequest::set_cf(const ::std::string& value) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchDeleteRequest.cf)
}
#if LANG_CXX11
inline void RawBatchDeleteRequest::set_cf(::std::string&& value) {
  
  cf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawBatchDeleteRequest.cf)
}
#endif
inline void RawBatchDeleteRequest::set_cf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawBatchDeleteRequest.cf)
}
inline void RawBatchDeleteRequest::set_cf(const char* value, size_t size) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawBatchDeleteRequest.cf)
}
inline ::std::string* RawBatchDeleteRequest::mutable_cf() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchDeleteRequest.cf)
  return cf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawBatchDeleteRequest::release_cf() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchDeleteRequest.cf)
  
  return cf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawBatchDeleteRequest::set_allocated_cf(::std::string* cf) {
  if (cf != NULL) {
    
  } else {
    
  }
  cf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cf);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchDeleteRequest.cf)
}

// -------------------------------------------------------------------

// RawBatchDeleteResponse

// .errorpb.Error region_error = 1;
inline bool RawBatchDeleteResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& RawBatchDeleteResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& RawBatchDeleteResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchDeleteResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* RawBatchDeleteResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchDeleteResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* RawBatchDeleteResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchDeleteResponse.region_error)
  return region_error_;
}
inline void RawBatchDeleteResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchDeleteResponse.region_error)
}

// string error = 2;
inline void RawBatchDeleteResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawBatchDeleteResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchDeleteResponse.error)
  return error_.GetNoArena();
}
inline void RawBatchDeleteResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchDeleteResponse.error)
}
#if LANG_CXX11
inline void RawBatchDeleteResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawBatchDeleteResponse.error)
}
#endif
inline void RawBatchDeleteResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawBatchDeleteResponse.error)
}
inline void RawBatchDeleteResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawBatchDeleteResponse.error)
}
inline ::std::string* RawBatchDeleteResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchDeleteResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawBatchDeleteResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchDeleteResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawBatchDeleteResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchDeleteResponse.error)
}

// -------------------------------------------------------------------

// DeleteRangeRequest

// .kvrpcpb.Context context = 1;
inline bool DeleteRangeRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void DeleteRangeRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& DeleteRangeRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& DeleteRangeRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRangeRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* DeleteRangeRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DeleteRangeRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* DeleteRangeRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRangeRequest.context)
  return context_;
}
inline void DeleteRangeRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DeleteRangeRequest.context)
}

// bytes start_key = 2;
inline void DeleteRangeRequest::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRangeRequest::start_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRangeRequest.start_key)
  return start_key_.GetNoArena();
}
inline void DeleteRangeRequest::set_start_key(const ::std::string& value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteRangeRequest.start_key)
}
#if LANG_CXX11
inline void DeleteRangeRequest::set_start_key(::std::string&& value) {
  
  start_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.DeleteRangeRequest.start_key)
}
#endif
inline void DeleteRangeRequest::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.DeleteRangeRequest.start_key)
}
inline void DeleteRangeRequest::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.DeleteRangeRequest.start_key)
}
inline ::std::string* DeleteRangeRequest::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRangeRequest.start_key)
  return start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRangeRequest::release_start_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DeleteRangeRequest.start_key)
  
  return start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRangeRequest::set_allocated_start_key(::std::string* start_key) {
  if (start_key != NULL) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DeleteRangeRequest.start_key)
}

// bytes end_key = 3;
inline void DeleteRangeRequest::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRangeRequest::end_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRangeRequest.end_key)
  return end_key_.GetNoArena();
}
inline void DeleteRangeRequest::set_end_key(const ::std::string& value) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteRangeRequest.end_key)
}
#if LANG_CXX11
inline void DeleteRangeRequest::set_end_key(::std::string&& value) {
  
  end_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.DeleteRangeRequest.end_key)
}
#endif
inline void DeleteRangeRequest::set_end_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.DeleteRangeRequest.end_key)
}
inline void DeleteRangeRequest::set_end_key(const void* value, size_t size) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.DeleteRangeRequest.end_key)
}
inline ::std::string* DeleteRangeRequest::mutable_end_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRangeRequest.end_key)
  return end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRangeRequest::release_end_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DeleteRangeRequest.end_key)
  
  return end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRangeRequest::set_allocated_end_key(::std::string* end_key) {
  if (end_key != NULL) {
    
  } else {
    
  }
  end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DeleteRangeRequest.end_key)
}

// -------------------------------------------------------------------

// DeleteRangeResponse

// .errorpb.Error region_error = 1;
inline bool DeleteRangeResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& DeleteRangeResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& DeleteRangeResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRangeResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* DeleteRangeResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DeleteRangeResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* DeleteRangeResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRangeResponse.region_error)
  return region_error_;
}
inline void DeleteRangeResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DeleteRangeResponse.region_error)
}

// string error = 2;
inline void DeleteRangeResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRangeResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.DeleteRangeResponse.error)
  return error_.GetNoArena();
}
inline void DeleteRangeResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.DeleteRangeResponse.error)
}
#if LANG_CXX11
inline void DeleteRangeResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.DeleteRangeResponse.error)
}
#endif
inline void DeleteRangeResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.DeleteRangeResponse.error)
}
inline void DeleteRangeResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.DeleteRangeResponse.error)
}
inline ::std::string* DeleteRangeResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.DeleteRangeResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRangeResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.DeleteRangeResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRangeResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.DeleteRangeResponse.error)
}

// -------------------------------------------------------------------

// RawDeleteRangeRequest

// .kvrpcpb.Context context = 1;
inline bool RawDeleteRangeRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void RawDeleteRangeRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& RawDeleteRangeRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& RawDeleteRangeRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteRangeRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* RawDeleteRangeRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteRangeRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* RawDeleteRangeRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteRangeRequest.context)
  return context_;
}
inline void RawDeleteRangeRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteRangeRequest.context)
}

// bytes start_key = 2;
inline void RawDeleteRangeRequest::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawDeleteRangeRequest::start_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteRangeRequest.start_key)
  return start_key_.GetNoArena();
}
inline void RawDeleteRangeRequest::set_start_key(const ::std::string& value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawDeleteRangeRequest.start_key)
}
#if LANG_CXX11
inline void RawDeleteRangeRequest::set_start_key(::std::string&& value) {
  
  start_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawDeleteRangeRequest.start_key)
}
#endif
inline void RawDeleteRangeRequest::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawDeleteRangeRequest.start_key)
}
inline void RawDeleteRangeRequest::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawDeleteRangeRequest.start_key)
}
inline ::std::string* RawDeleteRangeRequest::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteRangeRequest.start_key)
  return start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawDeleteRangeRequest::release_start_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteRangeRequest.start_key)
  
  return start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawDeleteRangeRequest::set_allocated_start_key(::std::string* start_key) {
  if (start_key != NULL) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteRangeRequest.start_key)
}

// bytes end_key = 3;
inline void RawDeleteRangeRequest::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawDeleteRangeRequest::end_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteRangeRequest.end_key)
  return end_key_.GetNoArena();
}
inline void RawDeleteRangeRequest::set_end_key(const ::std::string& value) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawDeleteRangeRequest.end_key)
}
#if LANG_CXX11
inline void RawDeleteRangeRequest::set_end_key(::std::string&& value) {
  
  end_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawDeleteRangeRequest.end_key)
}
#endif
inline void RawDeleteRangeRequest::set_end_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawDeleteRangeRequest.end_key)
}
inline void RawDeleteRangeRequest::set_end_key(const void* value, size_t size) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawDeleteRangeRequest.end_key)
}
inline ::std::string* RawDeleteRangeRequest::mutable_end_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteRangeRequest.end_key)
  return end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawDeleteRangeRequest::release_end_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteRangeRequest.end_key)
  
  return end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawDeleteRangeRequest::set_allocated_end_key(::std::string* end_key) {
  if (end_key != NULL) {
    
  } else {
    
  }
  end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteRangeRequest.end_key)
}

// string cf = 4;
inline void RawDeleteRangeRequest::clear_cf() {
  cf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawDeleteRangeRequest::cf() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteRangeRequest.cf)
  return cf_.GetNoArena();
}
inline void RawDeleteRangeRequest::set_cf(const ::std::string& value) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawDeleteRangeRequest.cf)
}
#if LANG_CXX11
inline void RawDeleteRangeRequest::set_cf(::std::string&& value) {
  
  cf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawDeleteRangeRequest.cf)
}
#endif
inline void RawDeleteRangeRequest::set_cf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawDeleteRangeRequest.cf)
}
inline void RawDeleteRangeRequest::set_cf(const char* value, size_t size) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawDeleteRangeRequest.cf)
}
inline ::std::string* RawDeleteRangeRequest::mutable_cf() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteRangeRequest.cf)
  return cf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawDeleteRangeRequest::release_cf() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteRangeRequest.cf)
  
  return cf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawDeleteRangeRequest::set_allocated_cf(::std::string* cf) {
  if (cf != NULL) {
    
  } else {
    
  }
  cf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cf);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteRangeRequest.cf)
}

// -------------------------------------------------------------------

// RawDeleteRangeResponse

// .errorpb.Error region_error = 1;
inline bool RawDeleteRangeResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& RawDeleteRangeResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& RawDeleteRangeResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteRangeResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* RawDeleteRangeResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteRangeResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* RawDeleteRangeResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteRangeResponse.region_error)
  return region_error_;
}
inline void RawDeleteRangeResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteRangeResponse.region_error)
}

// string error = 2;
inline void RawDeleteRangeResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawDeleteRangeResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawDeleteRangeResponse.error)
  return error_.GetNoArena();
}
inline void RawDeleteRangeResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawDeleteRangeResponse.error)
}
#if LANG_CXX11
inline void RawDeleteRangeResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawDeleteRangeResponse.error)
}
#endif
inline void RawDeleteRangeResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawDeleteRangeResponse.error)
}
inline void RawDeleteRangeResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawDeleteRangeResponse.error)
}
inline ::std::string* RawDeleteRangeResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawDeleteRangeResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawDeleteRangeResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawDeleteRangeResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawDeleteRangeResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawDeleteRangeResponse.error)
}

// -------------------------------------------------------------------

// RawScanRequest

// .kvrpcpb.Context context = 1;
inline bool RawScanRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void RawScanRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& RawScanRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& RawScanRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawScanRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* RawScanRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawScanRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* RawScanRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawScanRequest.context)
  return context_;
}
inline void RawScanRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawScanRequest.context)
}

// bytes start_key = 2;
inline void RawScanRequest::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawScanRequest::start_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawScanRequest.start_key)
  return start_key_.GetNoArena();
}
inline void RawScanRequest::set_start_key(const ::std::string& value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawScanRequest.start_key)
}
#if LANG_CXX11
inline void RawScanRequest::set_start_key(::std::string&& value) {
  
  start_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawScanRequest.start_key)
}
#endif
inline void RawScanRequest::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawScanRequest.start_key)
}
inline void RawScanRequest::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawScanRequest.start_key)
}
inline ::std::string* RawScanRequest::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawScanRequest.start_key)
  return start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawScanRequest::release_start_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawScanRequest.start_key)
  
  return start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawScanRequest::set_allocated_start_key(::std::string* start_key) {
  if (start_key != NULL) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawScanRequest.start_key)
}

// uint32 limit = 3;
inline void RawScanRequest::clear_limit() {
  limit_ = 0u;
}
inline ::google::protobuf::uint32 RawScanRequest::limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawScanRequest.limit)
  return limit_;
}
inline void RawScanRequest::set_limit(::google::protobuf::uint32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RawScanRequest.limit)
}

// bool key_only = 4;
inline void RawScanRequest::clear_key_only() {
  key_only_ = false;
}
inline bool RawScanRequest::key_only() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawScanRequest.key_only)
  return key_only_;
}
inline void RawScanRequest::set_key_only(bool value) {
  
  key_only_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RawScanRequest.key_only)
}

// string cf = 5;
inline void RawScanRequest::clear_cf() {
  cf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawScanRequest::cf() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawScanRequest.cf)
  return cf_.GetNoArena();
}
inline void RawScanRequest::set_cf(const ::std::string& value) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawScanRequest.cf)
}
#if LANG_CXX11
inline void RawScanRequest::set_cf(::std::string&& value) {
  
  cf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawScanRequest.cf)
}
#endif
inline void RawScanRequest::set_cf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawScanRequest.cf)
}
inline void RawScanRequest::set_cf(const char* value, size_t size) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawScanRequest.cf)
}
inline ::std::string* RawScanRequest::mutable_cf() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawScanRequest.cf)
  return cf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawScanRequest::release_cf() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawScanRequest.cf)
  
  return cf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawScanRequest::set_allocated_cf(::std::string* cf) {
  if (cf != NULL) {
    
  } else {
    
  }
  cf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cf);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawScanRequest.cf)
}

// -------------------------------------------------------------------

// RawScanResponse

// .errorpb.Error region_error = 1;
inline bool RawScanResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& RawScanResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& RawScanResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawScanResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* RawScanResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawScanResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* RawScanResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawScanResponse.region_error)
  return region_error_;
}
inline void RawScanResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawScanResponse.region_error)
}

// repeated .kvrpcpb.KvPair kvs = 2;
inline int RawScanResponse::kvs_size() const {
  return kvs_.size();
}
inline void RawScanResponse::clear_kvs() {
  kvs_.Clear();
}
inline ::kvrpcpb::KvPair* RawScanResponse::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawScanResponse.kvs)
  return kvs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
RawScanResponse::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.RawScanResponse.kvs)
  return &kvs_;
}
inline const ::kvrpcpb::KvPair& RawScanResponse::kvs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawScanResponse.kvs)
  return kvs_.Get(index);
}
inline ::kvrpcpb::KvPair* RawScanResponse::add_kvs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.RawScanResponse.kvs)
  return kvs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
RawScanResponse::kvs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.RawScanResponse.kvs)
  return kvs_;
}

// -------------------------------------------------------------------

// KeyRange

// bytes start_key = 1;
inline void KeyRange::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyRange::start_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyRange.start_key)
  return start_key_.GetNoArena();
}
inline void KeyRange::set_start_key(const ::std::string& value) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyRange.start_key)
}
#if LANG_CXX11
inline void KeyRange::set_start_key(::std::string&& value) {
  
  start_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KeyRange.start_key)
}
#endif
inline void KeyRange::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KeyRange.start_key)
}
inline void KeyRange::set_start_key(const void* value, size_t size) {
  
  start_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KeyRange.start_key)
}
inline ::std::string* KeyRange::mutable_start_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyRange.start_key)
  return start_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyRange::release_start_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KeyRange.start_key)
  
  return start_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyRange::set_allocated_start_key(::std::string* start_key) {
  if (start_key != NULL) {
    
  } else {
    
  }
  start_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyRange.start_key)
}

// bytes end_key = 2;
inline void KeyRange::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyRange::end_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyRange.end_key)
  return end_key_.GetNoArena();
}
inline void KeyRange::set_end_key(const ::std::string& value) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyRange.end_key)
}
#if LANG_CXX11
inline void KeyRange::set_end_key(::std::string&& value) {
  
  end_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.KeyRange.end_key)
}
#endif
inline void KeyRange::set_end_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KeyRange.end_key)
}
inline void KeyRange::set_end_key(const void* value, size_t size) {
  
  end_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KeyRange.end_key)
}
inline ::std::string* KeyRange::mutable_end_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyRange.end_key)
  return end_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyRange::release_end_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.KeyRange.end_key)
  
  return end_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyRange::set_allocated_end_key(::std::string* end_key) {
  if (end_key != NULL) {
    
  } else {
    
  }
  end_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyRange.end_key)
}

// -------------------------------------------------------------------

// RawBatchScanRequest

// .kvrpcpb.Context context = 1;
inline bool RawBatchScanRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void RawBatchScanRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& RawBatchScanRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& RawBatchScanRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchScanRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* RawBatchScanRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchScanRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* RawBatchScanRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchScanRequest.context)
  return context_;
}
inline void RawBatchScanRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchScanRequest.context)
}

// repeated .kvrpcpb.KeyRange ranges = 2;
inline int RawBatchScanRequest::ranges_size() const {
  return ranges_.size();
}
inline void RawBatchScanRequest::clear_ranges() {
  ranges_.Clear();
}
inline ::kvrpcpb::KeyRange* RawBatchScanRequest::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchScanRequest.ranges)
  return ranges_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyRange >*
RawBatchScanRequest::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.RawBatchScanRequest.ranges)
  return &ranges_;
}
inline const ::kvrpcpb::KeyRange& RawBatchScanRequest::ranges(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchScanRequest.ranges)
  return ranges_.Get(index);
}
inline ::kvrpcpb::KeyRange* RawBatchScanRequest::add_ranges() {
  // @@protoc_insertion_point(field_add:kvrpcpb.RawBatchScanRequest.ranges)
  return ranges_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyRange >&
RawBatchScanRequest::ranges() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.RawBatchScanRequest.ranges)
  return ranges_;
}

// uint32 each_limit = 3;
inline void RawBatchScanRequest::clear_each_limit() {
  each_limit_ = 0u;
}
inline ::google::protobuf::uint32 RawBatchScanRequest::each_limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchScanRequest.each_limit)
  return each_limit_;
}
inline void RawBatchScanRequest::set_each_limit(::google::protobuf::uint32 value) {
  
  each_limit_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchScanRequest.each_limit)
}

// bool key_only = 4;
inline void RawBatchScanRequest::clear_key_only() {
  key_only_ = false;
}
inline bool RawBatchScanRequest::key_only() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchScanRequest.key_only)
  return key_only_;
}
inline void RawBatchScanRequest::set_key_only(bool value) {
  
  key_only_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchScanRequest.key_only)
}

// string cf = 5;
inline void RawBatchScanRequest::clear_cf() {
  cf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RawBatchScanRequest::cf() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchScanRequest.cf)
  return cf_.GetNoArena();
}
inline void RawBatchScanRequest::set_cf(const ::std::string& value) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.RawBatchScanRequest.cf)
}
#if LANG_CXX11
inline void RawBatchScanRequest::set_cf(::std::string&& value) {
  
  cf_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.RawBatchScanRequest.cf)
}
#endif
inline void RawBatchScanRequest::set_cf(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.RawBatchScanRequest.cf)
}
inline void RawBatchScanRequest::set_cf(const char* value, size_t size) {
  
  cf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.RawBatchScanRequest.cf)
}
inline ::std::string* RawBatchScanRequest::mutable_cf() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchScanRequest.cf)
  return cf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RawBatchScanRequest::release_cf() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchScanRequest.cf)
  
  return cf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RawBatchScanRequest::set_allocated_cf(::std::string* cf) {
  if (cf != NULL) {
    
  } else {
    
  }
  cf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cf);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchScanRequest.cf)
}

// -------------------------------------------------------------------

// RawBatchScanResponse

// .errorpb.Error region_error = 1;
inline bool RawBatchScanResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& RawBatchScanResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& RawBatchScanResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchScanResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* RawBatchScanResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.RawBatchScanResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* RawBatchScanResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchScanResponse.region_error)
  return region_error_;
}
inline void RawBatchScanResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.RawBatchScanResponse.region_error)
}

// repeated .kvrpcpb.KvPair kvs = 2;
inline int RawBatchScanResponse::kvs_size() const {
  return kvs_.size();
}
inline void RawBatchScanResponse::clear_kvs() {
  kvs_.Clear();
}
inline ::kvrpcpb::KvPair* RawBatchScanResponse::mutable_kvs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.RawBatchScanResponse.kvs)
  return kvs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
RawBatchScanResponse::mutable_kvs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.RawBatchScanResponse.kvs)
  return &kvs_;
}
inline const ::kvrpcpb::KvPair& RawBatchScanResponse::kvs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.RawBatchScanResponse.kvs)
  return kvs_.Get(index);
}
inline ::kvrpcpb::KvPair* RawBatchScanResponse::add_kvs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.RawBatchScanResponse.kvs)
  return kvs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
RawBatchScanResponse::kvs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.RawBatchScanResponse.kvs)
  return kvs_;
}

// -------------------------------------------------------------------

// MvccWrite

// .kvrpcpb.Op type = 1;
inline void MvccWrite::clear_type() {
  type_ = 0;
}
inline ::kvrpcpb::Op MvccWrite::type() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccWrite.type)
  return static_cast< ::kvrpcpb::Op >(type_);
}
inline void MvccWrite::set_type(::kvrpcpb::Op value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccWrite.type)
}

// uint64 start_ts = 2;
inline void MvccWrite::clear_start_ts() {
  start_ts_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 MvccWrite::start_ts() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccWrite.start_ts)
  return start_ts_;
}
inline void MvccWrite::set_start_ts(::google::protobuf::uint64 value) {
  
  start_ts_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccWrite.start_ts)
}

// uint64 commit_ts = 3;
inline void MvccWrite::clear_commit_ts() {
  commit_ts_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 MvccWrite::commit_ts() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccWrite.commit_ts)
  return commit_ts_;
}
inline void MvccWrite::set_commit_ts(::google::protobuf::uint64 value) {
  
  commit_ts_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccWrite.commit_ts)
}

// bytes short_value = 4;
inline void MvccWrite::clear_short_value() {
  short_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MvccWrite::short_value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccWrite.short_value)
  return short_value_.GetNoArena();
}
inline void MvccWrite::set_short_value(const ::std::string& value) {
  
  short_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccWrite.short_value)
}
#if LANG_CXX11
inline void MvccWrite::set_short_value(::std::string&& value) {
  
  short_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.MvccWrite.short_value)
}
#endif
inline void MvccWrite::set_short_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  short_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.MvccWrite.short_value)
}
inline void MvccWrite::set_short_value(const void* value, size_t size) {
  
  short_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.MvccWrite.short_value)
}
inline ::std::string* MvccWrite::mutable_short_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccWrite.short_value)
  return short_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MvccWrite::release_short_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccWrite.short_value)
  
  return short_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MvccWrite::set_allocated_short_value(::std::string* short_value) {
  if (short_value != NULL) {
    
  } else {
    
  }
  short_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), short_value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccWrite.short_value)
}

// -------------------------------------------------------------------

// MvccValue

// uint64 start_ts = 1;
inline void MvccValue::clear_start_ts() {
  start_ts_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 MvccValue::start_ts() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccValue.start_ts)
  return start_ts_;
}
inline void MvccValue::set_start_ts(::google::protobuf::uint64 value) {
  
  start_ts_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccValue.start_ts)
}

// bytes value = 2;
inline void MvccValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MvccValue::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccValue.value)
  return value_.GetNoArena();
}
inline void MvccValue::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccValue.value)
}
#if LANG_CXX11
inline void MvccValue::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.MvccValue.value)
}
#endif
inline void MvccValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.MvccValue.value)
}
inline void MvccValue::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.MvccValue.value)
}
inline ::std::string* MvccValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MvccValue::release_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccValue.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MvccValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccValue.value)
}

// -------------------------------------------------------------------

// MvccLock

// .kvrpcpb.Op type = 1;
inline void MvccLock::clear_type() {
  type_ = 0;
}
inline ::kvrpcpb::Op MvccLock::type() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccLock.type)
  return static_cast< ::kvrpcpb::Op >(type_);
}
inline void MvccLock::set_type(::kvrpcpb::Op value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccLock.type)
}

// uint64 start_ts = 2;
inline void MvccLock::clear_start_ts() {
  start_ts_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 MvccLock::start_ts() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccLock.start_ts)
  return start_ts_;
}
inline void MvccLock::set_start_ts(::google::protobuf::uint64 value) {
  
  start_ts_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccLock.start_ts)
}

// bytes primary = 3;
inline void MvccLock::clear_primary() {
  primary_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MvccLock::primary() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccLock.primary)
  return primary_.GetNoArena();
}
inline void MvccLock::set_primary(const ::std::string& value) {
  
  primary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccLock.primary)
}
#if LANG_CXX11
inline void MvccLock::set_primary(::std::string&& value) {
  
  primary_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.MvccLock.primary)
}
#endif
inline void MvccLock::set_primary(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  primary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.MvccLock.primary)
}
inline void MvccLock::set_primary(const void* value, size_t size) {
  
  primary_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.MvccLock.primary)
}
inline ::std::string* MvccLock::mutable_primary() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccLock.primary)
  return primary_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MvccLock::release_primary() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccLock.primary)
  
  return primary_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MvccLock::set_allocated_primary(::std::string* primary) {
  if (primary != NULL) {
    
  } else {
    
  }
  primary_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), primary);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccLock.primary)
}

// bytes short_value = 4;
inline void MvccLock::clear_short_value() {
  short_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MvccLock::short_value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccLock.short_value)
  return short_value_.GetNoArena();
}
inline void MvccLock::set_short_value(const ::std::string& value) {
  
  short_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccLock.short_value)
}
#if LANG_CXX11
inline void MvccLock::set_short_value(::std::string&& value) {
  
  short_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.MvccLock.short_value)
}
#endif
inline void MvccLock::set_short_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  short_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.MvccLock.short_value)
}
inline void MvccLock::set_short_value(const void* value, size_t size) {
  
  short_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.MvccLock.short_value)
}
inline ::std::string* MvccLock::mutable_short_value() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccLock.short_value)
  return short_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MvccLock::release_short_value() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccLock.short_value)
  
  return short_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MvccLock::set_allocated_short_value(::std::string* short_value) {
  if (short_value != NULL) {
    
  } else {
    
  }
  short_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), short_value);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccLock.short_value)
}

// -------------------------------------------------------------------

// MvccInfo

// .kvrpcpb.MvccLock lock = 1;
inline bool MvccInfo::has_lock() const {
  return this != internal_default_instance() && lock_ != NULL;
}
inline void MvccInfo::clear_lock() {
  if (GetArenaNoVirtual() == NULL && lock_ != NULL) {
    delete lock_;
  }
  lock_ = NULL;
}
inline const ::kvrpcpb::MvccLock& MvccInfo::_internal_lock() const {
  return *lock_;
}
inline const ::kvrpcpb::MvccLock& MvccInfo::lock() const {
  const ::kvrpcpb::MvccLock* p = lock_;
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccInfo.lock)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::MvccLock*>(
      &::kvrpcpb::_MvccLock_default_instance_);
}
inline ::kvrpcpb::MvccLock* MvccInfo::release_lock() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccInfo.lock)
  
  ::kvrpcpb::MvccLock* temp = lock_;
  lock_ = NULL;
  return temp;
}
inline ::kvrpcpb::MvccLock* MvccInfo::mutable_lock() {
  
  if (lock_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::MvccLock>(GetArenaNoVirtual());
    lock_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccInfo.lock)
  return lock_;
}
inline void MvccInfo::set_allocated_lock(::kvrpcpb::MvccLock* lock) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lock_;
  }
  if (lock) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lock = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lock, submessage_arena);
    }
    
  } else {
    
  }
  lock_ = lock;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccInfo.lock)
}

// repeated .kvrpcpb.MvccWrite writes = 2;
inline int MvccInfo::writes_size() const {
  return writes_.size();
}
inline void MvccInfo::clear_writes() {
  writes_.Clear();
}
inline ::kvrpcpb::MvccWrite* MvccInfo::mutable_writes(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccInfo.writes)
  return writes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::MvccWrite >*
MvccInfo::mutable_writes() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.MvccInfo.writes)
  return &writes_;
}
inline const ::kvrpcpb::MvccWrite& MvccInfo::writes(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccInfo.writes)
  return writes_.Get(index);
}
inline ::kvrpcpb::MvccWrite* MvccInfo::add_writes() {
  // @@protoc_insertion_point(field_add:kvrpcpb.MvccInfo.writes)
  return writes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::MvccWrite >&
MvccInfo::writes() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.MvccInfo.writes)
  return writes_;
}

// repeated .kvrpcpb.MvccValue values = 3;
inline int MvccInfo::values_size() const {
  return values_.size();
}
inline void MvccInfo::clear_values() {
  values_.Clear();
}
inline ::kvrpcpb::MvccValue* MvccInfo::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccInfo.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::MvccValue >*
MvccInfo::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.MvccInfo.values)
  return &values_;
}
inline const ::kvrpcpb::MvccValue& MvccInfo::values(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccInfo.values)
  return values_.Get(index);
}
inline ::kvrpcpb::MvccValue* MvccInfo::add_values() {
  // @@protoc_insertion_point(field_add:kvrpcpb.MvccInfo.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::MvccValue >&
MvccInfo::values() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.MvccInfo.values)
  return values_;
}

// -------------------------------------------------------------------

// MvccGetByKeyRequest

// .kvrpcpb.Context context = 1;
inline bool MvccGetByKeyRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void MvccGetByKeyRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& MvccGetByKeyRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& MvccGetByKeyRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByKeyRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* MvccGetByKeyRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccGetByKeyRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* MvccGetByKeyRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccGetByKeyRequest.context)
  return context_;
}
inline void MvccGetByKeyRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccGetByKeyRequest.context)
}

// bytes key = 2;
inline void MvccGetByKeyRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MvccGetByKeyRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByKeyRequest.key)
  return key_.GetNoArena();
}
inline void MvccGetByKeyRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccGetByKeyRequest.key)
}
#if LANG_CXX11
inline void MvccGetByKeyRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.MvccGetByKeyRequest.key)
}
#endif
inline void MvccGetByKeyRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.MvccGetByKeyRequest.key)
}
inline void MvccGetByKeyRequest::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.MvccGetByKeyRequest.key)
}
inline ::std::string* MvccGetByKeyRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccGetByKeyRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MvccGetByKeyRequest::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccGetByKeyRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MvccGetByKeyRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccGetByKeyRequest.key)
}

// -------------------------------------------------------------------

// MvccGetByKeyResponse

// .errorpb.Error region_error = 1;
inline bool MvccGetByKeyResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& MvccGetByKeyResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& MvccGetByKeyResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByKeyResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* MvccGetByKeyResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccGetByKeyResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* MvccGetByKeyResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccGetByKeyResponse.region_error)
  return region_error_;
}
inline void MvccGetByKeyResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccGetByKeyResponse.region_error)
}

// string error = 2;
inline void MvccGetByKeyResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MvccGetByKeyResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByKeyResponse.error)
  return error_.GetNoArena();
}
inline void MvccGetByKeyResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccGetByKeyResponse.error)
}
#if LANG_CXX11
inline void MvccGetByKeyResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.MvccGetByKeyResponse.error)
}
#endif
inline void MvccGetByKeyResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.MvccGetByKeyResponse.error)
}
inline void MvccGetByKeyResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.MvccGetByKeyResponse.error)
}
inline ::std::string* MvccGetByKeyResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccGetByKeyResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MvccGetByKeyResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccGetByKeyResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MvccGetByKeyResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccGetByKeyResponse.error)
}

// .kvrpcpb.MvccInfo info = 3;
inline bool MvccGetByKeyResponse::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void MvccGetByKeyResponse::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) {
    delete info_;
  }
  info_ = NULL;
}
inline const ::kvrpcpb::MvccInfo& MvccGetByKeyResponse::_internal_info() const {
  return *info_;
}
inline const ::kvrpcpb::MvccInfo& MvccGetByKeyResponse::info() const {
  const ::kvrpcpb::MvccInfo* p = info_;
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByKeyResponse.info)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::MvccInfo*>(
      &::kvrpcpb::_MvccInfo_default_instance_);
}
inline ::kvrpcpb::MvccInfo* MvccGetByKeyResponse::release_info() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccGetByKeyResponse.info)
  
  ::kvrpcpb::MvccInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::kvrpcpb::MvccInfo* MvccGetByKeyResponse::mutable_info() {
  
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::MvccInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccGetByKeyResponse.info)
  return info_;
}
inline void MvccGetByKeyResponse::set_allocated_info(::kvrpcpb::MvccInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccGetByKeyResponse.info)
}

// -------------------------------------------------------------------

// MvccGetByStartTsRequest

// .kvrpcpb.Context context = 1;
inline bool MvccGetByStartTsRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void MvccGetByStartTsRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& MvccGetByStartTsRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& MvccGetByStartTsRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByStartTsRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* MvccGetByStartTsRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccGetByStartTsRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* MvccGetByStartTsRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccGetByStartTsRequest.context)
  return context_;
}
inline void MvccGetByStartTsRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccGetByStartTsRequest.context)
}

// uint64 start_ts = 2;
inline void MvccGetByStartTsRequest::clear_start_ts() {
  start_ts_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 MvccGetByStartTsRequest::start_ts() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByStartTsRequest.start_ts)
  return start_ts_;
}
inline void MvccGetByStartTsRequest::set_start_ts(::google::protobuf::uint64 value) {
  
  start_ts_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccGetByStartTsRequest.start_ts)
}

// -------------------------------------------------------------------

// MvccGetByStartTsResponse

// .errorpb.Error region_error = 1;
inline bool MvccGetByStartTsResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& MvccGetByStartTsResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& MvccGetByStartTsResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByStartTsResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* MvccGetByStartTsResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccGetByStartTsResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* MvccGetByStartTsResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccGetByStartTsResponse.region_error)
  return region_error_;
}
inline void MvccGetByStartTsResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccGetByStartTsResponse.region_error)
}

// string error = 2;
inline void MvccGetByStartTsResponse::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MvccGetByStartTsResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByStartTsResponse.error)
  return error_.GetNoArena();
}
inline void MvccGetByStartTsResponse::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccGetByStartTsResponse.error)
}
#if LANG_CXX11
inline void MvccGetByStartTsResponse::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.MvccGetByStartTsResponse.error)
}
#endif
inline void MvccGetByStartTsResponse::set_error(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.MvccGetByStartTsResponse.error)
}
inline void MvccGetByStartTsResponse::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.MvccGetByStartTsResponse.error)
}
inline ::std::string* MvccGetByStartTsResponse::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccGetByStartTsResponse.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MvccGetByStartTsResponse::release_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccGetByStartTsResponse.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MvccGetByStartTsResponse::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccGetByStartTsResponse.error)
}

// bytes key = 3;
inline void MvccGetByStartTsResponse::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MvccGetByStartTsResponse::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByStartTsResponse.key)
  return key_.GetNoArena();
}
inline void MvccGetByStartTsResponse::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.MvccGetByStartTsResponse.key)
}
#if LANG_CXX11
inline void MvccGetByStartTsResponse::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.MvccGetByStartTsResponse.key)
}
#endif
inline void MvccGetByStartTsResponse::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.MvccGetByStartTsResponse.key)
}
inline void MvccGetByStartTsResponse::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.MvccGetByStartTsResponse.key)
}
inline ::std::string* MvccGetByStartTsResponse::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccGetByStartTsResponse.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MvccGetByStartTsResponse::release_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccGetByStartTsResponse.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MvccGetByStartTsResponse::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccGetByStartTsResponse.key)
}

// .kvrpcpb.MvccInfo info = 4;
inline bool MvccGetByStartTsResponse::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void MvccGetByStartTsResponse::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) {
    delete info_;
  }
  info_ = NULL;
}
inline const ::kvrpcpb::MvccInfo& MvccGetByStartTsResponse::_internal_info() const {
  return *info_;
}
inline const ::kvrpcpb::MvccInfo& MvccGetByStartTsResponse::info() const {
  const ::kvrpcpb::MvccInfo* p = info_;
  // @@protoc_insertion_point(field_get:kvrpcpb.MvccGetByStartTsResponse.info)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::MvccInfo*>(
      &::kvrpcpb::_MvccInfo_default_instance_);
}
inline ::kvrpcpb::MvccInfo* MvccGetByStartTsResponse::release_info() {
  // @@protoc_insertion_point(field_release:kvrpcpb.MvccGetByStartTsResponse.info)
  
  ::kvrpcpb::MvccInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::kvrpcpb::MvccInfo* MvccGetByStartTsResponse::mutable_info() {
  
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::MvccInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.MvccGetByStartTsResponse.info)
  return info_;
}
inline void MvccGetByStartTsResponse::set_allocated_info(::kvrpcpb::MvccInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.MvccGetByStartTsResponse.info)
}

// -------------------------------------------------------------------

// SplitRegionRequest

// .kvrpcpb.Context context = 1;
inline bool SplitRegionRequest::has_context() const {
  return this != internal_default_instance() && context_ != NULL;
}
inline void SplitRegionRequest::clear_context() {
  if (GetArenaNoVirtual() == NULL && context_ != NULL) {
    delete context_;
  }
  context_ = NULL;
}
inline const ::kvrpcpb::Context& SplitRegionRequest::_internal_context() const {
  return *context_;
}
inline const ::kvrpcpb::Context& SplitRegionRequest::context() const {
  const ::kvrpcpb::Context* p = context_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SplitRegionRequest.context)
  return p != NULL ? *p : *reinterpret_cast<const ::kvrpcpb::Context*>(
      &::kvrpcpb::_Context_default_instance_);
}
inline ::kvrpcpb::Context* SplitRegionRequest::release_context() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SplitRegionRequest.context)
  
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline ::kvrpcpb::Context* SplitRegionRequest::mutable_context() {
  
  if (context_ == NULL) {
    auto* p = CreateMaybeMessage<::kvrpcpb::Context>(GetArenaNoVirtual());
    context_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SplitRegionRequest.context)
  return context_;
}
inline void SplitRegionRequest::set_allocated_context(::kvrpcpb::Context* context) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete context_;
  }
  if (context) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      context = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SplitRegionRequest.context)
}

// bytes split_key = 2;
inline void SplitRegionRequest::clear_split_key() {
  split_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SplitRegionRequest::split_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.SplitRegionRequest.split_key)
  return split_key_.GetNoArena();
}
inline void SplitRegionRequest::set_split_key(const ::std::string& value) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:kvrpcpb.SplitRegionRequest.split_key)
}
#if LANG_CXX11
inline void SplitRegionRequest::set_split_key(::std::string&& value) {
  
  split_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:kvrpcpb.SplitRegionRequest.split_key)
}
#endif
inline void SplitRegionRequest::set_split_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:kvrpcpb.SplitRegionRequest.split_key)
}
inline void SplitRegionRequest::set_split_key(const void* value, size_t size) {
  
  split_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.SplitRegionRequest.split_key)
}
inline ::std::string* SplitRegionRequest::mutable_split_key() {
  
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SplitRegionRequest.split_key)
  return split_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SplitRegionRequest::release_split_key() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SplitRegionRequest.split_key)
  
  return split_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SplitRegionRequest::set_allocated_split_key(::std::string* split_key) {
  if (split_key != NULL) {
    
  } else {
    
  }
  split_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), split_key);
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SplitRegionRequest.split_key)
}

// -------------------------------------------------------------------

// SplitRegionResponse

// .errorpb.Error region_error = 1;
inline bool SplitRegionResponse::has_region_error() const {
  return this != internal_default_instance() && region_error_ != NULL;
}
inline const ::errorpb::Error& SplitRegionResponse::_internal_region_error() const {
  return *region_error_;
}
inline const ::errorpb::Error& SplitRegionResponse::region_error() const {
  const ::errorpb::Error* p = region_error_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SplitRegionResponse.region_error)
  return p != NULL ? *p : *reinterpret_cast<const ::errorpb::Error*>(
      &::errorpb::_Error_default_instance_);
}
inline ::errorpb::Error* SplitRegionResponse::release_region_error() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SplitRegionResponse.region_error)
  
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline ::errorpb::Error* SplitRegionResponse::mutable_region_error() {
  
  if (region_error_ == NULL) {
    auto* p = CreateMaybeMessage<::errorpb::Error>(GetArenaNoVirtual());
    region_error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SplitRegionResponse.region_error)
  return region_error_;
}
inline void SplitRegionResponse::set_allocated_region_error(::errorpb::Error* region_error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_error_);
  }
  if (region_error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region_error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region_error, submessage_arena);
    }
    
  } else {
    
  }
  region_error_ = region_error;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SplitRegionResponse.region_error)
}

// .metapb.Region left = 2;
inline bool SplitRegionResponse::has_left() const {
  return this != internal_default_instance() && left_ != NULL;
}
inline const ::metapb::Region& SplitRegionResponse::_internal_left() const {
  return *left_;
}
inline const ::metapb::Region& SplitRegionResponse::left() const {
  const ::metapb::Region* p = left_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SplitRegionResponse.left)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* SplitRegionResponse::release_left() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SplitRegionResponse.left)
  
  ::metapb::Region* temp = left_;
  left_ = NULL;
  return temp;
}
inline ::metapb::Region* SplitRegionResponse::mutable_left() {
  
  if (left_ == NULL) {
    auto* p = CreateMaybeMessage<::metapb::Region>(GetArenaNoVirtual());
    left_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SplitRegionResponse.left)
  return left_;
}
inline void SplitRegionResponse::set_allocated_left(::metapb::Region* left) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(left_);
  }
  if (left) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      left = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left, submessage_arena);
    }
    
  } else {
    
  }
  left_ = left;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SplitRegionResponse.left)
}

// .metapb.Region right = 3;
inline bool SplitRegionResponse::has_right() const {
  return this != internal_default_instance() && right_ != NULL;
}
inline const ::metapb::Region& SplitRegionResponse::_internal_right() const {
  return *right_;
}
inline const ::metapb::Region& SplitRegionResponse::right() const {
  const ::metapb::Region* p = right_;
  // @@protoc_insertion_point(field_get:kvrpcpb.SplitRegionResponse.right)
  return p != NULL ? *p : *reinterpret_cast<const ::metapb::Region*>(
      &::metapb::_Region_default_instance_);
}
inline ::metapb::Region* SplitRegionResponse::release_right() {
  // @@protoc_insertion_point(field_release:kvrpcpb.SplitRegionResponse.right)
  
  ::metapb::Region* temp = right_;
  right_ = NULL;
  return temp;
}
inline ::metapb::Region* SplitRegionResponse::mutable_right() {
  
  if (right_ == NULL) {
    auto* p = CreateMaybeMessage<::metapb::Region>(GetArenaNoVirtual());
    right_ = p;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.SplitRegionResponse.right)
  return right_;
}
inline void SplitRegionResponse::set_allocated_right(::metapb::Region* right) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(right_);
  }
  if (right) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      right = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right, submessage_arena);
    }
    
  } else {
    
  }
  right_ = right;
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.SplitRegionResponse.right)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace kvrpcpb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::kvrpcpb::CommandPri> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::CommandPri>() {
  return ::kvrpcpb::CommandPri_descriptor();
}
template <> struct is_proto_enum< ::kvrpcpb::IsolationLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::IsolationLevel>() {
  return ::kvrpcpb::IsolationLevel_descriptor();
}
template <> struct is_proto_enum< ::kvrpcpb::Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::Op>() {
  return ::kvrpcpb::Op_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_kvrpcpb_2eproto
