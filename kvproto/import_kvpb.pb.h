// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: import_kvpb.proto

#ifndef PROTOBUF_INCLUDED_import_5fkvpb_2eproto
#define PROTOBUF_INCLUDED_import_5fkvpb_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "import_sstpb.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_import_5fkvpb_2eproto 

namespace protobuf_import_5fkvpb_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[19];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_import_5fkvpb_2eproto
namespace import_kvpb {
class CleanupEngineRequest;
class CleanupEngineRequestDefaultTypeInternal;
extern CleanupEngineRequestDefaultTypeInternal _CleanupEngineRequest_default_instance_;
class CleanupEngineResponse;
class CleanupEngineResponseDefaultTypeInternal;
extern CleanupEngineResponseDefaultTypeInternal _CleanupEngineResponse_default_instance_;
class CloseEngineRequest;
class CloseEngineRequestDefaultTypeInternal;
extern CloseEngineRequestDefaultTypeInternal _CloseEngineRequest_default_instance_;
class CloseEngineResponse;
class CloseEngineResponseDefaultTypeInternal;
extern CloseEngineResponseDefaultTypeInternal _CloseEngineResponse_default_instance_;
class CompactClusterRequest;
class CompactClusterRequestDefaultTypeInternal;
extern CompactClusterRequestDefaultTypeInternal _CompactClusterRequest_default_instance_;
class CompactClusterResponse;
class CompactClusterResponseDefaultTypeInternal;
extern CompactClusterResponseDefaultTypeInternal _CompactClusterResponse_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class Error_EngineNotFound;
class Error_EngineNotFoundDefaultTypeInternal;
extern Error_EngineNotFoundDefaultTypeInternal _Error_EngineNotFound_default_instance_;
class ImportEngineRequest;
class ImportEngineRequestDefaultTypeInternal;
extern ImportEngineRequestDefaultTypeInternal _ImportEngineRequest_default_instance_;
class ImportEngineResponse;
class ImportEngineResponseDefaultTypeInternal;
extern ImportEngineResponseDefaultTypeInternal _ImportEngineResponse_default_instance_;
class Mutation;
class MutationDefaultTypeInternal;
extern MutationDefaultTypeInternal _Mutation_default_instance_;
class OpenEngineRequest;
class OpenEngineRequestDefaultTypeInternal;
extern OpenEngineRequestDefaultTypeInternal _OpenEngineRequest_default_instance_;
class OpenEngineResponse;
class OpenEngineResponseDefaultTypeInternal;
extern OpenEngineResponseDefaultTypeInternal _OpenEngineResponse_default_instance_;
class SwitchModeRequest;
class SwitchModeRequestDefaultTypeInternal;
extern SwitchModeRequestDefaultTypeInternal _SwitchModeRequest_default_instance_;
class SwitchModeResponse;
class SwitchModeResponseDefaultTypeInternal;
extern SwitchModeResponseDefaultTypeInternal _SwitchModeResponse_default_instance_;
class WriteBatch;
class WriteBatchDefaultTypeInternal;
extern WriteBatchDefaultTypeInternal _WriteBatch_default_instance_;
class WriteEngineRequest;
class WriteEngineRequestDefaultTypeInternal;
extern WriteEngineRequestDefaultTypeInternal _WriteEngineRequest_default_instance_;
class WriteEngineResponse;
class WriteEngineResponseDefaultTypeInternal;
extern WriteEngineResponseDefaultTypeInternal _WriteEngineResponse_default_instance_;
class WriteHead;
class WriteHeadDefaultTypeInternal;
extern WriteHeadDefaultTypeInternal _WriteHead_default_instance_;
}  // namespace import_kvpb
namespace google {
namespace protobuf {
template<> ::import_kvpb::CleanupEngineRequest* Arena::CreateMaybeMessage<::import_kvpb::CleanupEngineRequest>(Arena*);
template<> ::import_kvpb::CleanupEngineResponse* Arena::CreateMaybeMessage<::import_kvpb::CleanupEngineResponse>(Arena*);
template<> ::import_kvpb::CloseEngineRequest* Arena::CreateMaybeMessage<::import_kvpb::CloseEngineRequest>(Arena*);
template<> ::import_kvpb::CloseEngineResponse* Arena::CreateMaybeMessage<::import_kvpb::CloseEngineResponse>(Arena*);
template<> ::import_kvpb::CompactClusterRequest* Arena::CreateMaybeMessage<::import_kvpb::CompactClusterRequest>(Arena*);
template<> ::import_kvpb::CompactClusterResponse* Arena::CreateMaybeMessage<::import_kvpb::CompactClusterResponse>(Arena*);
template<> ::import_kvpb::Error* Arena::CreateMaybeMessage<::import_kvpb::Error>(Arena*);
template<> ::import_kvpb::Error_EngineNotFound* Arena::CreateMaybeMessage<::import_kvpb::Error_EngineNotFound>(Arena*);
template<> ::import_kvpb::ImportEngineRequest* Arena::CreateMaybeMessage<::import_kvpb::ImportEngineRequest>(Arena*);
template<> ::import_kvpb::ImportEngineResponse* Arena::CreateMaybeMessage<::import_kvpb::ImportEngineResponse>(Arena*);
template<> ::import_kvpb::Mutation* Arena::CreateMaybeMessage<::import_kvpb::Mutation>(Arena*);
template<> ::import_kvpb::OpenEngineRequest* Arena::CreateMaybeMessage<::import_kvpb::OpenEngineRequest>(Arena*);
template<> ::import_kvpb::OpenEngineResponse* Arena::CreateMaybeMessage<::import_kvpb::OpenEngineResponse>(Arena*);
template<> ::import_kvpb::SwitchModeRequest* Arena::CreateMaybeMessage<::import_kvpb::SwitchModeRequest>(Arena*);
template<> ::import_kvpb::SwitchModeResponse* Arena::CreateMaybeMessage<::import_kvpb::SwitchModeResponse>(Arena*);
template<> ::import_kvpb::WriteBatch* Arena::CreateMaybeMessage<::import_kvpb::WriteBatch>(Arena*);
template<> ::import_kvpb::WriteEngineRequest* Arena::CreateMaybeMessage<::import_kvpb::WriteEngineRequest>(Arena*);
template<> ::import_kvpb::WriteEngineResponse* Arena::CreateMaybeMessage<::import_kvpb::WriteEngineResponse>(Arena*);
template<> ::import_kvpb::WriteHead* Arena::CreateMaybeMessage<::import_kvpb::WriteHead>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace import_kvpb {

enum Mutation_OP {
  Mutation_OP_Put = 0,
  Mutation_OP_Mutation_OP_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Mutation_OP_Mutation_OP_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Mutation_OP_IsValid(int value);
const Mutation_OP Mutation_OP_OP_MIN = Mutation_OP_Put;
const Mutation_OP Mutation_OP_OP_MAX = Mutation_OP_Put;
const int Mutation_OP_OP_ARRAYSIZE = Mutation_OP_OP_MAX + 1;

const ::google::protobuf::EnumDescriptor* Mutation_OP_descriptor();
inline const ::std::string& Mutation_OP_Name(Mutation_OP value) {
  return ::google::protobuf::internal::NameOfEnum(
    Mutation_OP_descriptor(), value);
}
inline bool Mutation_OP_Parse(
    const ::std::string& name, Mutation_OP* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Mutation_OP>(
    Mutation_OP_descriptor(), name, value);
}
// ===================================================================

class SwitchModeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.SwitchModeRequest) */ {
 public:
  SwitchModeRequest();
  virtual ~SwitchModeRequest();

  SwitchModeRequest(const SwitchModeRequest& from);

  inline SwitchModeRequest& operator=(const SwitchModeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchModeRequest(SwitchModeRequest&& from) noexcept
    : SwitchModeRequest() {
    *this = ::std::move(from);
  }

  inline SwitchModeRequest& operator=(SwitchModeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchModeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchModeRequest* internal_default_instance() {
    return reinterpret_cast<const SwitchModeRequest*>(
               &_SwitchModeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SwitchModeRequest* other);
  friend void swap(SwitchModeRequest& a, SwitchModeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchModeRequest* New() const final {
    return CreateMaybeMessage<SwitchModeRequest>(NULL);
  }

  SwitchModeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchModeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchModeRequest& from);
  void MergeFrom(const SwitchModeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchModeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pd_addr = 1;
  void clear_pd_addr();
  static const int kPdAddrFieldNumber = 1;
  const ::std::string& pd_addr() const;
  void set_pd_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_pd_addr(::std::string&& value);
  #endif
  void set_pd_addr(const char* value);
  void set_pd_addr(const char* value, size_t size);
  ::std::string* mutable_pd_addr();
  ::std::string* release_pd_addr();
  void set_allocated_pd_addr(::std::string* pd_addr);

  // .import_sstpb.SwitchModeRequest request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  private:
  const ::import_sstpb::SwitchModeRequest& _internal_request() const;
  public:
  const ::import_sstpb::SwitchModeRequest& request() const;
  ::import_sstpb::SwitchModeRequest* release_request();
  ::import_sstpb::SwitchModeRequest* mutable_request();
  void set_allocated_request(::import_sstpb::SwitchModeRequest* request);

  // @@protoc_insertion_point(class_scope:import_kvpb.SwitchModeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pd_addr_;
  ::import_sstpb::SwitchModeRequest* request_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SwitchModeResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.SwitchModeResponse) */ {
 public:
  SwitchModeResponse();
  virtual ~SwitchModeResponse();

  SwitchModeResponse(const SwitchModeResponse& from);

  inline SwitchModeResponse& operator=(const SwitchModeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SwitchModeResponse(SwitchModeResponse&& from) noexcept
    : SwitchModeResponse() {
    *this = ::std::move(from);
  }

  inline SwitchModeResponse& operator=(SwitchModeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SwitchModeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchModeResponse* internal_default_instance() {
    return reinterpret_cast<const SwitchModeResponse*>(
               &_SwitchModeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SwitchModeResponse* other);
  friend void swap(SwitchModeResponse& a, SwitchModeResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SwitchModeResponse* New() const final {
    return CreateMaybeMessage<SwitchModeResponse>(NULL);
  }

  SwitchModeResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SwitchModeResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SwitchModeResponse& from);
  void MergeFrom(const SwitchModeResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchModeResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:import_kvpb.SwitchModeResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpenEngineRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.OpenEngineRequest) */ {
 public:
  OpenEngineRequest();
  virtual ~OpenEngineRequest();

  OpenEngineRequest(const OpenEngineRequest& from);

  inline OpenEngineRequest& operator=(const OpenEngineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenEngineRequest(OpenEngineRequest&& from) noexcept
    : OpenEngineRequest() {
    *this = ::std::move(from);
  }

  inline OpenEngineRequest& operator=(OpenEngineRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenEngineRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenEngineRequest* internal_default_instance() {
    return reinterpret_cast<const OpenEngineRequest*>(
               &_OpenEngineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(OpenEngineRequest* other);
  friend void swap(OpenEngineRequest& a, OpenEngineRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenEngineRequest* New() const final {
    return CreateMaybeMessage<OpenEngineRequest>(NULL);
  }

  OpenEngineRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OpenEngineRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OpenEngineRequest& from);
  void MergeFrom(const OpenEngineRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenEngineRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:import_kvpb.OpenEngineRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpenEngineResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.OpenEngineResponse) */ {
 public:
  OpenEngineResponse();
  virtual ~OpenEngineResponse();

  OpenEngineResponse(const OpenEngineResponse& from);

  inline OpenEngineResponse& operator=(const OpenEngineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpenEngineResponse(OpenEngineResponse&& from) noexcept
    : OpenEngineResponse() {
    *this = ::std::move(from);
  }

  inline OpenEngineResponse& operator=(OpenEngineResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenEngineResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpenEngineResponse* internal_default_instance() {
    return reinterpret_cast<const OpenEngineResponse*>(
               &_OpenEngineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(OpenEngineResponse* other);
  friend void swap(OpenEngineResponse& a, OpenEngineResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpenEngineResponse* New() const final {
    return CreateMaybeMessage<OpenEngineResponse>(NULL);
  }

  OpenEngineResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OpenEngineResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OpenEngineResponse& from);
  void MergeFrom(const OpenEngineResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenEngineResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:import_kvpb.OpenEngineResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteHead : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.WriteHead) */ {
 public:
  WriteHead();
  virtual ~WriteHead();

  WriteHead(const WriteHead& from);

  inline WriteHead& operator=(const WriteHead& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteHead(WriteHead&& from) noexcept
    : WriteHead() {
    *this = ::std::move(from);
  }

  inline WriteHead& operator=(WriteHead&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteHead& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteHead* internal_default_instance() {
    return reinterpret_cast<const WriteHead*>(
               &_WriteHead_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(WriteHead* other);
  friend void swap(WriteHead& a, WriteHead& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteHead* New() const final {
    return CreateMaybeMessage<WriteHead>(NULL);
  }

  WriteHead* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteHead>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteHead& from);
  void MergeFrom(const WriteHead& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteHead* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:import_kvpb.WriteHead)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Mutation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.Mutation) */ {
 public:
  Mutation();
  virtual ~Mutation();

  Mutation(const Mutation& from);

  inline Mutation& operator=(const Mutation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mutation(Mutation&& from) noexcept
    : Mutation() {
    *this = ::std::move(from);
  }

  inline Mutation& operator=(Mutation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Mutation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mutation* internal_default_instance() {
    return reinterpret_cast<const Mutation*>(
               &_Mutation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Mutation* other);
  friend void swap(Mutation& a, Mutation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mutation* New() const final {
    return CreateMaybeMessage<Mutation>(NULL);
  }

  Mutation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mutation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mutation& from);
  void MergeFrom(const Mutation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mutation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Mutation_OP OP;
  static const OP Put =
    Mutation_OP_Put;
  static inline bool OP_IsValid(int value) {
    return Mutation_OP_IsValid(value);
  }
  static const OP OP_MIN =
    Mutation_OP_OP_MIN;
  static const OP OP_MAX =
    Mutation_OP_OP_MAX;
  static const int OP_ARRAYSIZE =
    Mutation_OP_OP_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OP_descriptor() {
    return Mutation_OP_descriptor();
  }
  static inline const ::std::string& OP_Name(OP value) {
    return Mutation_OP_Name(value);
  }
  static inline bool OP_Parse(const ::std::string& name,
      OP* value) {
    return Mutation_OP_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .import_kvpb.Mutation.OP op = 1;
  void clear_op();
  static const int kOpFieldNumber = 1;
  ::import_kvpb::Mutation_OP op() const;
  void set_op(::import_kvpb::Mutation_OP value);

  // @@protoc_insertion_point(class_scope:import_kvpb.Mutation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  int op_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteBatch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.WriteBatch) */ {
 public:
  WriteBatch();
  virtual ~WriteBatch();

  WriteBatch(const WriteBatch& from);

  inline WriteBatch& operator=(const WriteBatch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteBatch(WriteBatch&& from) noexcept
    : WriteBatch() {
    *this = ::std::move(from);
  }

  inline WriteBatch& operator=(WriteBatch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteBatch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteBatch* internal_default_instance() {
    return reinterpret_cast<const WriteBatch*>(
               &_WriteBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(WriteBatch* other);
  friend void swap(WriteBatch& a, WriteBatch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteBatch* New() const final {
    return CreateMaybeMessage<WriteBatch>(NULL);
  }

  WriteBatch* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteBatch>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteBatch& from);
  void MergeFrom(const WriteBatch& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteBatch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .import_kvpb.Mutation mutations = 2;
  int mutations_size() const;
  void clear_mutations();
  static const int kMutationsFieldNumber = 2;
  ::import_kvpb::Mutation* mutable_mutations(int index);
  ::google::protobuf::RepeatedPtrField< ::import_kvpb::Mutation >*
      mutable_mutations();
  const ::import_kvpb::Mutation& mutations(int index) const;
  ::import_kvpb::Mutation* add_mutations();
  const ::google::protobuf::RepeatedPtrField< ::import_kvpb::Mutation >&
      mutations() const;

  // uint64 commit_ts = 1;
  void clear_commit_ts();
  static const int kCommitTsFieldNumber = 1;
  ::google::protobuf::uint64 commit_ts() const;
  void set_commit_ts(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:import_kvpb.WriteBatch)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::import_kvpb::Mutation > mutations_;
  ::google::protobuf::uint64 commit_ts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteEngineRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.WriteEngineRequest) */ {
 public:
  WriteEngineRequest();
  virtual ~WriteEngineRequest();

  WriteEngineRequest(const WriteEngineRequest& from);

  inline WriteEngineRequest& operator=(const WriteEngineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteEngineRequest(WriteEngineRequest&& from) noexcept
    : WriteEngineRequest() {
    *this = ::std::move(from);
  }

  inline WriteEngineRequest& operator=(WriteEngineRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteEngineRequest& default_instance();

  enum ChunkCase {
    kHead = 1,
    kBatch = 2,
    CHUNK_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteEngineRequest* internal_default_instance() {
    return reinterpret_cast<const WriteEngineRequest*>(
               &_WriteEngineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(WriteEngineRequest* other);
  friend void swap(WriteEngineRequest& a, WriteEngineRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteEngineRequest* New() const final {
    return CreateMaybeMessage<WriteEngineRequest>(NULL);
  }

  WriteEngineRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteEngineRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteEngineRequest& from);
  void MergeFrom(const WriteEngineRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteEngineRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .import_kvpb.WriteHead head = 1;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 1;
  private:
  const ::import_kvpb::WriteHead& _internal_head() const;
  public:
  const ::import_kvpb::WriteHead& head() const;
  ::import_kvpb::WriteHead* release_head();
  ::import_kvpb::WriteHead* mutable_head();
  void set_allocated_head(::import_kvpb::WriteHead* head);

  // .import_kvpb.WriteBatch batch = 2;
  bool has_batch() const;
  void clear_batch();
  static const int kBatchFieldNumber = 2;
  private:
  const ::import_kvpb::WriteBatch& _internal_batch() const;
  public:
  const ::import_kvpb::WriteBatch& batch() const;
  ::import_kvpb::WriteBatch* release_batch();
  ::import_kvpb::WriteBatch* mutable_batch();
  void set_allocated_batch(::import_kvpb::WriteBatch* batch);

  void clear_chunk();
  ChunkCase chunk_case() const;
  // @@protoc_insertion_point(class_scope:import_kvpb.WriteEngineRequest)
 private:
  void set_has_head();
  void set_has_batch();

  inline bool has_chunk() const;
  inline void clear_has_chunk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ChunkUnion {
    ChunkUnion() {}
    ::import_kvpb::WriteHead* head_;
    ::import_kvpb::WriteBatch* batch_;
  } chunk_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteEngineResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.WriteEngineResponse) */ {
 public:
  WriteEngineResponse();
  virtual ~WriteEngineResponse();

  WriteEngineResponse(const WriteEngineResponse& from);

  inline WriteEngineResponse& operator=(const WriteEngineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteEngineResponse(WriteEngineResponse&& from) noexcept
    : WriteEngineResponse() {
    *this = ::std::move(from);
  }

  inline WriteEngineResponse& operator=(WriteEngineResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteEngineResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteEngineResponse* internal_default_instance() {
    return reinterpret_cast<const WriteEngineResponse*>(
               &_WriteEngineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(WriteEngineResponse* other);
  friend void swap(WriteEngineResponse& a, WriteEngineResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteEngineResponse* New() const final {
    return CreateMaybeMessage<WriteEngineResponse>(NULL);
  }

  WriteEngineResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteEngineResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteEngineResponse& from);
  void MergeFrom(const WriteEngineResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteEngineResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .import_kvpb.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::import_kvpb::Error& _internal_error() const;
  public:
  const ::import_kvpb::Error& error() const;
  ::import_kvpb::Error* release_error();
  ::import_kvpb::Error* mutable_error();
  void set_allocated_error(::import_kvpb::Error* error);

  // @@protoc_insertion_point(class_scope:import_kvpb.WriteEngineResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::import_kvpb::Error* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseEngineRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.CloseEngineRequest) */ {
 public:
  CloseEngineRequest();
  virtual ~CloseEngineRequest();

  CloseEngineRequest(const CloseEngineRequest& from);

  inline CloseEngineRequest& operator=(const CloseEngineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseEngineRequest(CloseEngineRequest&& from) noexcept
    : CloseEngineRequest() {
    *this = ::std::move(from);
  }

  inline CloseEngineRequest& operator=(CloseEngineRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseEngineRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseEngineRequest* internal_default_instance() {
    return reinterpret_cast<const CloseEngineRequest*>(
               &_CloseEngineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(CloseEngineRequest* other);
  friend void swap(CloseEngineRequest& a, CloseEngineRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseEngineRequest* New() const final {
    return CreateMaybeMessage<CloseEngineRequest>(NULL);
  }

  CloseEngineRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloseEngineRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloseEngineRequest& from);
  void MergeFrom(const CloseEngineRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseEngineRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:import_kvpb.CloseEngineRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseEngineResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.CloseEngineResponse) */ {
 public:
  CloseEngineResponse();
  virtual ~CloseEngineResponse();

  CloseEngineResponse(const CloseEngineResponse& from);

  inline CloseEngineResponse& operator=(const CloseEngineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseEngineResponse(CloseEngineResponse&& from) noexcept
    : CloseEngineResponse() {
    *this = ::std::move(from);
  }

  inline CloseEngineResponse& operator=(CloseEngineResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseEngineResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloseEngineResponse* internal_default_instance() {
    return reinterpret_cast<const CloseEngineResponse*>(
               &_CloseEngineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CloseEngineResponse* other);
  friend void swap(CloseEngineResponse& a, CloseEngineResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseEngineResponse* New() const final {
    return CreateMaybeMessage<CloseEngineResponse>(NULL);
  }

  CloseEngineResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloseEngineResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloseEngineResponse& from);
  void MergeFrom(const CloseEngineResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseEngineResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .import_kvpb.Error error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  private:
  const ::import_kvpb::Error& _internal_error() const;
  public:
  const ::import_kvpb::Error& error() const;
  ::import_kvpb::Error* release_error();
  ::import_kvpb::Error* mutable_error();
  void set_allocated_error(::import_kvpb::Error* error);

  // @@protoc_insertion_point(class_scope:import_kvpb.CloseEngineResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::import_kvpb::Error* error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImportEngineRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.ImportEngineRequest) */ {
 public:
  ImportEngineRequest();
  virtual ~ImportEngineRequest();

  ImportEngineRequest(const ImportEngineRequest& from);

  inline ImportEngineRequest& operator=(const ImportEngineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImportEngineRequest(ImportEngineRequest&& from) noexcept
    : ImportEngineRequest() {
    *this = ::std::move(from);
  }

  inline ImportEngineRequest& operator=(ImportEngineRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportEngineRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImportEngineRequest* internal_default_instance() {
    return reinterpret_cast<const ImportEngineRequest*>(
               &_ImportEngineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ImportEngineRequest* other);
  friend void swap(ImportEngineRequest& a, ImportEngineRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImportEngineRequest* New() const final {
    return CreateMaybeMessage<ImportEngineRequest>(NULL);
  }

  ImportEngineRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImportEngineRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImportEngineRequest& from);
  void MergeFrom(const ImportEngineRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportEngineRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // string pd_addr = 2;
  void clear_pd_addr();
  static const int kPdAddrFieldNumber = 2;
  const ::std::string& pd_addr() const;
  void set_pd_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_pd_addr(::std::string&& value);
  #endif
  void set_pd_addr(const char* value);
  void set_pd_addr(const char* value, size_t size);
  ::std::string* mutable_pd_addr();
  ::std::string* release_pd_addr();
  void set_allocated_pd_addr(::std::string* pd_addr);

  // @@protoc_insertion_point(class_scope:import_kvpb.ImportEngineRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  ::google::protobuf::internal::ArenaStringPtr pd_addr_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImportEngineResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.ImportEngineResponse) */ {
 public:
  ImportEngineResponse();
  virtual ~ImportEngineResponse();

  ImportEngineResponse(const ImportEngineResponse& from);

  inline ImportEngineResponse& operator=(const ImportEngineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImportEngineResponse(ImportEngineResponse&& from) noexcept
    : ImportEngineResponse() {
    *this = ::std::move(from);
  }

  inline ImportEngineResponse& operator=(ImportEngineResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImportEngineResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImportEngineResponse* internal_default_instance() {
    return reinterpret_cast<const ImportEngineResponse*>(
               &_ImportEngineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ImportEngineResponse* other);
  friend void swap(ImportEngineResponse& a, ImportEngineResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImportEngineResponse* New() const final {
    return CreateMaybeMessage<ImportEngineResponse>(NULL);
  }

  ImportEngineResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImportEngineResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImportEngineResponse& from);
  void MergeFrom(const ImportEngineResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImportEngineResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:import_kvpb.ImportEngineResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CleanupEngineRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.CleanupEngineRequest) */ {
 public:
  CleanupEngineRequest();
  virtual ~CleanupEngineRequest();

  CleanupEngineRequest(const CleanupEngineRequest& from);

  inline CleanupEngineRequest& operator=(const CleanupEngineRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CleanupEngineRequest(CleanupEngineRequest&& from) noexcept
    : CleanupEngineRequest() {
    *this = ::std::move(from);
  }

  inline CleanupEngineRequest& operator=(CleanupEngineRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanupEngineRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CleanupEngineRequest* internal_default_instance() {
    return reinterpret_cast<const CleanupEngineRequest*>(
               &_CleanupEngineRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CleanupEngineRequest* other);
  friend void swap(CleanupEngineRequest& a, CleanupEngineRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CleanupEngineRequest* New() const final {
    return CreateMaybeMessage<CleanupEngineRequest>(NULL);
  }

  CleanupEngineRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CleanupEngineRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CleanupEngineRequest& from);
  void MergeFrom(const CleanupEngineRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanupEngineRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:import_kvpb.CleanupEngineRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CleanupEngineResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.CleanupEngineResponse) */ {
 public:
  CleanupEngineResponse();
  virtual ~CleanupEngineResponse();

  CleanupEngineResponse(const CleanupEngineResponse& from);

  inline CleanupEngineResponse& operator=(const CleanupEngineResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CleanupEngineResponse(CleanupEngineResponse&& from) noexcept
    : CleanupEngineResponse() {
    *this = ::std::move(from);
  }

  inline CleanupEngineResponse& operator=(CleanupEngineResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CleanupEngineResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CleanupEngineResponse* internal_default_instance() {
    return reinterpret_cast<const CleanupEngineResponse*>(
               &_CleanupEngineResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CleanupEngineResponse* other);
  friend void swap(CleanupEngineResponse& a, CleanupEngineResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CleanupEngineResponse* New() const final {
    return CreateMaybeMessage<CleanupEngineResponse>(NULL);
  }

  CleanupEngineResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CleanupEngineResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CleanupEngineResponse& from);
  void MergeFrom(const CleanupEngineResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanupEngineResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:import_kvpb.CleanupEngineResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CompactClusterRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.CompactClusterRequest) */ {
 public:
  CompactClusterRequest();
  virtual ~CompactClusterRequest();

  CompactClusterRequest(const CompactClusterRequest& from);

  inline CompactClusterRequest& operator=(const CompactClusterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CompactClusterRequest(CompactClusterRequest&& from) noexcept
    : CompactClusterRequest() {
    *this = ::std::move(from);
  }

  inline CompactClusterRequest& operator=(CompactClusterRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompactClusterRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompactClusterRequest* internal_default_instance() {
    return reinterpret_cast<const CompactClusterRequest*>(
               &_CompactClusterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(CompactClusterRequest* other);
  friend void swap(CompactClusterRequest& a, CompactClusterRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CompactClusterRequest* New() const final {
    return CreateMaybeMessage<CompactClusterRequest>(NULL);
  }

  CompactClusterRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CompactClusterRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CompactClusterRequest& from);
  void MergeFrom(const CompactClusterRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompactClusterRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pd_addr = 1;
  void clear_pd_addr();
  static const int kPdAddrFieldNumber = 1;
  const ::std::string& pd_addr() const;
  void set_pd_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_pd_addr(::std::string&& value);
  #endif
  void set_pd_addr(const char* value);
  void set_pd_addr(const char* value, size_t size);
  ::std::string* mutable_pd_addr();
  ::std::string* release_pd_addr();
  void set_allocated_pd_addr(::std::string* pd_addr);

  // .import_sstpb.CompactRequest request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  private:
  const ::import_sstpb::CompactRequest& _internal_request() const;
  public:
  const ::import_sstpb::CompactRequest& request() const;
  ::import_sstpb::CompactRequest* release_request();
  ::import_sstpb::CompactRequest* mutable_request();
  void set_allocated_request(::import_sstpb::CompactRequest* request);

  // @@protoc_insertion_point(class_scope:import_kvpb.CompactClusterRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pd_addr_;
  ::import_sstpb::CompactRequest* request_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CompactClusterResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.CompactClusterResponse) */ {
 public:
  CompactClusterResponse();
  virtual ~CompactClusterResponse();

  CompactClusterResponse(const CompactClusterResponse& from);

  inline CompactClusterResponse& operator=(const CompactClusterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CompactClusterResponse(CompactClusterResponse&& from) noexcept
    : CompactClusterResponse() {
    *this = ::std::move(from);
  }

  inline CompactClusterResponse& operator=(CompactClusterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CompactClusterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompactClusterResponse* internal_default_instance() {
    return reinterpret_cast<const CompactClusterResponse*>(
               &_CompactClusterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(CompactClusterResponse* other);
  friend void swap(CompactClusterResponse& a, CompactClusterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CompactClusterResponse* New() const final {
    return CreateMaybeMessage<CompactClusterResponse>(NULL);
  }

  CompactClusterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CompactClusterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CompactClusterResponse& from);
  void MergeFrom(const CompactClusterResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompactClusterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:import_kvpb.CompactClusterResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error_EngineNotFound : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.Error.EngineNotFound) */ {
 public:
  Error_EngineNotFound();
  virtual ~Error_EngineNotFound();

  Error_EngineNotFound(const Error_EngineNotFound& from);

  inline Error_EngineNotFound& operator=(const Error_EngineNotFound& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error_EngineNotFound(Error_EngineNotFound&& from) noexcept
    : Error_EngineNotFound() {
    *this = ::std::move(from);
  }

  inline Error_EngineNotFound& operator=(Error_EngineNotFound&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error_EngineNotFound& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error_EngineNotFound* internal_default_instance() {
    return reinterpret_cast<const Error_EngineNotFound*>(
               &_Error_EngineNotFound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Error_EngineNotFound* other);
  friend void swap(Error_EngineNotFound& a, Error_EngineNotFound& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error_EngineNotFound* New() const final {
    return CreateMaybeMessage<Error_EngineNotFound>(NULL);
  }

  Error_EngineNotFound* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Error_EngineNotFound>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Error_EngineNotFound& from);
  void MergeFrom(const Error_EngineNotFound& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error_EngineNotFound* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes uuid = 1;
  void clear_uuid();
  static const int kUuidFieldNumber = 1;
  const ::std::string& uuid() const;
  void set_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_uuid(::std::string&& value);
  #endif
  void set_uuid(const char* value);
  void set_uuid(const void* value, size_t size);
  ::std::string* mutable_uuid();
  ::std::string* release_uuid();
  void set_allocated_uuid(::std::string* uuid);

  // @@protoc_insertion_point(class_scope:import_kvpb.Error.EngineNotFound)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr uuid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:import_kvpb.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(Error&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Error* other);
  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Error* New() const final {
    return CreateMaybeMessage<Error>(NULL);
  }

  Error* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Error_EngineNotFound EngineNotFound;

  // accessors -------------------------------------------------------

  // .import_kvpb.Error.EngineNotFound engine_not_found = 1;
  bool has_engine_not_found() const;
  void clear_engine_not_found();
  static const int kEngineNotFoundFieldNumber = 1;
  private:
  const ::import_kvpb::Error_EngineNotFound& _internal_engine_not_found() const;
  public:
  const ::import_kvpb::Error_EngineNotFound& engine_not_found() const;
  ::import_kvpb::Error_EngineNotFound* release_engine_not_found();
  ::import_kvpb::Error_EngineNotFound* mutable_engine_not_found();
  void set_allocated_engine_not_found(::import_kvpb::Error_EngineNotFound* engine_not_found);

  // @@protoc_insertion_point(class_scope:import_kvpb.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::import_kvpb::Error_EngineNotFound* engine_not_found_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_import_5fkvpb_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SwitchModeRequest

// string pd_addr = 1;
inline void SwitchModeRequest::clear_pd_addr() {
  pd_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SwitchModeRequest::pd_addr() const {
  // @@protoc_insertion_point(field_get:import_kvpb.SwitchModeRequest.pd_addr)
  return pd_addr_.GetNoArena();
}
inline void SwitchModeRequest::set_pd_addr(const ::std::string& value) {
  
  pd_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.SwitchModeRequest.pd_addr)
}
#if LANG_CXX11
inline void SwitchModeRequest::set_pd_addr(::std::string&& value) {
  
  pd_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.SwitchModeRequest.pd_addr)
}
#endif
inline void SwitchModeRequest::set_pd_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pd_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.SwitchModeRequest.pd_addr)
}
inline void SwitchModeRequest::set_pd_addr(const char* value, size_t size) {
  
  pd_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.SwitchModeRequest.pd_addr)
}
inline ::std::string* SwitchModeRequest::mutable_pd_addr() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.SwitchModeRequest.pd_addr)
  return pd_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SwitchModeRequest::release_pd_addr() {
  // @@protoc_insertion_point(field_release:import_kvpb.SwitchModeRequest.pd_addr)
  
  return pd_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SwitchModeRequest::set_allocated_pd_addr(::std::string* pd_addr) {
  if (pd_addr != NULL) {
    
  } else {
    
  }
  pd_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pd_addr);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.SwitchModeRequest.pd_addr)
}

// .import_sstpb.SwitchModeRequest request = 2;
inline bool SwitchModeRequest::has_request() const {
  return this != internal_default_instance() && request_ != NULL;
}
inline const ::import_sstpb::SwitchModeRequest& SwitchModeRequest::_internal_request() const {
  return *request_;
}
inline const ::import_sstpb::SwitchModeRequest& SwitchModeRequest::request() const {
  const ::import_sstpb::SwitchModeRequest* p = request_;
  // @@protoc_insertion_point(field_get:import_kvpb.SwitchModeRequest.request)
  return p != NULL ? *p : *reinterpret_cast<const ::import_sstpb::SwitchModeRequest*>(
      &::import_sstpb::_SwitchModeRequest_default_instance_);
}
inline ::import_sstpb::SwitchModeRequest* SwitchModeRequest::release_request() {
  // @@protoc_insertion_point(field_release:import_kvpb.SwitchModeRequest.request)
  
  ::import_sstpb::SwitchModeRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline ::import_sstpb::SwitchModeRequest* SwitchModeRequest::mutable_request() {
  
  if (request_ == NULL) {
    auto* p = CreateMaybeMessage<::import_sstpb::SwitchModeRequest>(GetArenaNoVirtual());
    request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:import_kvpb.SwitchModeRequest.request)
  return request_;
}
inline void SwitchModeRequest::set_allocated_request(::import_sstpb::SwitchModeRequest* request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(request_);
  }
  if (request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.SwitchModeRequest.request)
}

// -------------------------------------------------------------------

// SwitchModeResponse

// -------------------------------------------------------------------

// OpenEngineRequest

// bytes uuid = 1;
inline void OpenEngineRequest::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpenEngineRequest::uuid() const {
  // @@protoc_insertion_point(field_get:import_kvpb.OpenEngineRequest.uuid)
  return uuid_.GetNoArena();
}
inline void OpenEngineRequest::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.OpenEngineRequest.uuid)
}
#if LANG_CXX11
inline void OpenEngineRequest::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.OpenEngineRequest.uuid)
}
#endif
inline void OpenEngineRequest::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.OpenEngineRequest.uuid)
}
inline void OpenEngineRequest::set_uuid(const void* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.OpenEngineRequest.uuid)
}
inline ::std::string* OpenEngineRequest::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.OpenEngineRequest.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpenEngineRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:import_kvpb.OpenEngineRequest.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpenEngineRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.OpenEngineRequest.uuid)
}

// -------------------------------------------------------------------

// OpenEngineResponse

// -------------------------------------------------------------------

// WriteHead

// bytes uuid = 1;
inline void WriteHead::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteHead::uuid() const {
  // @@protoc_insertion_point(field_get:import_kvpb.WriteHead.uuid)
  return uuid_.GetNoArena();
}
inline void WriteHead::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.WriteHead.uuid)
}
#if LANG_CXX11
inline void WriteHead::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.WriteHead.uuid)
}
#endif
inline void WriteHead::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.WriteHead.uuid)
}
inline void WriteHead::set_uuid(const void* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.WriteHead.uuid)
}
inline ::std::string* WriteHead::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.WriteHead.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteHead::release_uuid() {
  // @@protoc_insertion_point(field_release:import_kvpb.WriteHead.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteHead::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.WriteHead.uuid)
}

// -------------------------------------------------------------------

// Mutation

// .import_kvpb.Mutation.OP op = 1;
inline void Mutation::clear_op() {
  op_ = 0;
}
inline ::import_kvpb::Mutation_OP Mutation::op() const {
  // @@protoc_insertion_point(field_get:import_kvpb.Mutation.op)
  return static_cast< ::import_kvpb::Mutation_OP >(op_);
}
inline void Mutation::set_op(::import_kvpb::Mutation_OP value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:import_kvpb.Mutation.op)
}

// bytes key = 2;
inline void Mutation::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mutation::key() const {
  // @@protoc_insertion_point(field_get:import_kvpb.Mutation.key)
  return key_.GetNoArena();
}
inline void Mutation::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.Mutation.key)
}
#if LANG_CXX11
inline void Mutation::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.Mutation.key)
}
#endif
inline void Mutation::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.Mutation.key)
}
inline void Mutation::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.Mutation.key)
}
inline ::std::string* Mutation::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.Mutation.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mutation::release_key() {
  // @@protoc_insertion_point(field_release:import_kvpb.Mutation.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutation::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.Mutation.key)
}

// bytes value = 3;
inline void Mutation::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mutation::value() const {
  // @@protoc_insertion_point(field_get:import_kvpb.Mutation.value)
  return value_.GetNoArena();
}
inline void Mutation::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.Mutation.value)
}
#if LANG_CXX11
inline void Mutation::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.Mutation.value)
}
#endif
inline void Mutation::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.Mutation.value)
}
inline void Mutation::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.Mutation.value)
}
inline ::std::string* Mutation::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.Mutation.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mutation::release_value() {
  // @@protoc_insertion_point(field_release:import_kvpb.Mutation.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mutation::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.Mutation.value)
}

// -------------------------------------------------------------------

// WriteBatch

// uint64 commit_ts = 1;
inline void WriteBatch::clear_commit_ts() {
  commit_ts_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 WriteBatch::commit_ts() const {
  // @@protoc_insertion_point(field_get:import_kvpb.WriteBatch.commit_ts)
  return commit_ts_;
}
inline void WriteBatch::set_commit_ts(::google::protobuf::uint64 value) {
  
  commit_ts_ = value;
  // @@protoc_insertion_point(field_set:import_kvpb.WriteBatch.commit_ts)
}

// repeated .import_kvpb.Mutation mutations = 2;
inline int WriteBatch::mutations_size() const {
  return mutations_.size();
}
inline void WriteBatch::clear_mutations() {
  mutations_.Clear();
}
inline ::import_kvpb::Mutation* WriteBatch::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:import_kvpb.WriteBatch.mutations)
  return mutations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::import_kvpb::Mutation >*
WriteBatch::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:import_kvpb.WriteBatch.mutations)
  return &mutations_;
}
inline const ::import_kvpb::Mutation& WriteBatch::mutations(int index) const {
  // @@protoc_insertion_point(field_get:import_kvpb.WriteBatch.mutations)
  return mutations_.Get(index);
}
inline ::import_kvpb::Mutation* WriteBatch::add_mutations() {
  // @@protoc_insertion_point(field_add:import_kvpb.WriteBatch.mutations)
  return mutations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::import_kvpb::Mutation >&
WriteBatch::mutations() const {
  // @@protoc_insertion_point(field_list:import_kvpb.WriteBatch.mutations)
  return mutations_;
}

// -------------------------------------------------------------------

// WriteEngineRequest

// .import_kvpb.WriteHead head = 1;
inline bool WriteEngineRequest::has_head() const {
  return chunk_case() == kHead;
}
inline void WriteEngineRequest::set_has_head() {
  _oneof_case_[0] = kHead;
}
inline void WriteEngineRequest::clear_head() {
  if (has_head()) {
    delete chunk_.head_;
    clear_has_chunk();
  }
}
inline const ::import_kvpb::WriteHead& WriteEngineRequest::_internal_head() const {
  return *chunk_.head_;
}
inline ::import_kvpb::WriteHead* WriteEngineRequest::release_head() {
  // @@protoc_insertion_point(field_release:import_kvpb.WriteEngineRequest.head)
  if (has_head()) {
    clear_has_chunk();
      ::import_kvpb::WriteHead* temp = chunk_.head_;
    chunk_.head_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::import_kvpb::WriteHead& WriteEngineRequest::head() const {
  // @@protoc_insertion_point(field_get:import_kvpb.WriteEngineRequest.head)
  return has_head()
      ? *chunk_.head_
      : *reinterpret_cast< ::import_kvpb::WriteHead*>(&::import_kvpb::_WriteHead_default_instance_);
}
inline ::import_kvpb::WriteHead* WriteEngineRequest::mutable_head() {
  if (!has_head()) {
    clear_chunk();
    set_has_head();
    chunk_.head_ = CreateMaybeMessage< ::import_kvpb::WriteHead >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:import_kvpb.WriteEngineRequest.head)
  return chunk_.head_;
}

// .import_kvpb.WriteBatch batch = 2;
inline bool WriteEngineRequest::has_batch() const {
  return chunk_case() == kBatch;
}
inline void WriteEngineRequest::set_has_batch() {
  _oneof_case_[0] = kBatch;
}
inline void WriteEngineRequest::clear_batch() {
  if (has_batch()) {
    delete chunk_.batch_;
    clear_has_chunk();
  }
}
inline const ::import_kvpb::WriteBatch& WriteEngineRequest::_internal_batch() const {
  return *chunk_.batch_;
}
inline ::import_kvpb::WriteBatch* WriteEngineRequest::release_batch() {
  // @@protoc_insertion_point(field_release:import_kvpb.WriteEngineRequest.batch)
  if (has_batch()) {
    clear_has_chunk();
      ::import_kvpb::WriteBatch* temp = chunk_.batch_;
    chunk_.batch_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::import_kvpb::WriteBatch& WriteEngineRequest::batch() const {
  // @@protoc_insertion_point(field_get:import_kvpb.WriteEngineRequest.batch)
  return has_batch()
      ? *chunk_.batch_
      : *reinterpret_cast< ::import_kvpb::WriteBatch*>(&::import_kvpb::_WriteBatch_default_instance_);
}
inline ::import_kvpb::WriteBatch* WriteEngineRequest::mutable_batch() {
  if (!has_batch()) {
    clear_chunk();
    set_has_batch();
    chunk_.batch_ = CreateMaybeMessage< ::import_kvpb::WriteBatch >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:import_kvpb.WriteEngineRequest.batch)
  return chunk_.batch_;
}

inline bool WriteEngineRequest::has_chunk() const {
  return chunk_case() != CHUNK_NOT_SET;
}
inline void WriteEngineRequest::clear_has_chunk() {
  _oneof_case_[0] = CHUNK_NOT_SET;
}
inline WriteEngineRequest::ChunkCase WriteEngineRequest::chunk_case() const {
  return WriteEngineRequest::ChunkCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WriteEngineResponse

// .import_kvpb.Error error = 1;
inline bool WriteEngineResponse::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void WriteEngineResponse::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::import_kvpb::Error& WriteEngineResponse::_internal_error() const {
  return *error_;
}
inline const ::import_kvpb::Error& WriteEngineResponse::error() const {
  const ::import_kvpb::Error* p = error_;
  // @@protoc_insertion_point(field_get:import_kvpb.WriteEngineResponse.error)
  return p != NULL ? *p : *reinterpret_cast<const ::import_kvpb::Error*>(
      &::import_kvpb::_Error_default_instance_);
}
inline ::import_kvpb::Error* WriteEngineResponse::release_error() {
  // @@protoc_insertion_point(field_release:import_kvpb.WriteEngineResponse.error)
  
  ::import_kvpb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::import_kvpb::Error* WriteEngineResponse::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::import_kvpb::Error>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:import_kvpb.WriteEngineResponse.error)
  return error_;
}
inline void WriteEngineResponse::set_allocated_error(::import_kvpb::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.WriteEngineResponse.error)
}

// -------------------------------------------------------------------

// CloseEngineRequest

// bytes uuid = 1;
inline void CloseEngineRequest::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CloseEngineRequest::uuid() const {
  // @@protoc_insertion_point(field_get:import_kvpb.CloseEngineRequest.uuid)
  return uuid_.GetNoArena();
}
inline void CloseEngineRequest::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.CloseEngineRequest.uuid)
}
#if LANG_CXX11
inline void CloseEngineRequest::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.CloseEngineRequest.uuid)
}
#endif
inline void CloseEngineRequest::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.CloseEngineRequest.uuid)
}
inline void CloseEngineRequest::set_uuid(const void* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.CloseEngineRequest.uuid)
}
inline ::std::string* CloseEngineRequest::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.CloseEngineRequest.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CloseEngineRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:import_kvpb.CloseEngineRequest.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CloseEngineRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.CloseEngineRequest.uuid)
}

// -------------------------------------------------------------------

// CloseEngineResponse

// .import_kvpb.Error error = 1;
inline bool CloseEngineResponse::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void CloseEngineResponse::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) {
    delete error_;
  }
  error_ = NULL;
}
inline const ::import_kvpb::Error& CloseEngineResponse::_internal_error() const {
  return *error_;
}
inline const ::import_kvpb::Error& CloseEngineResponse::error() const {
  const ::import_kvpb::Error* p = error_;
  // @@protoc_insertion_point(field_get:import_kvpb.CloseEngineResponse.error)
  return p != NULL ? *p : *reinterpret_cast<const ::import_kvpb::Error*>(
      &::import_kvpb::_Error_default_instance_);
}
inline ::import_kvpb::Error* CloseEngineResponse::release_error() {
  // @@protoc_insertion_point(field_release:import_kvpb.CloseEngineResponse.error)
  
  ::import_kvpb::Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::import_kvpb::Error* CloseEngineResponse::mutable_error() {
  
  if (error_ == NULL) {
    auto* p = CreateMaybeMessage<::import_kvpb::Error>(GetArenaNoVirtual());
    error_ = p;
  }
  // @@protoc_insertion_point(field_mutable:import_kvpb.CloseEngineResponse.error)
  return error_;
}
inline void CloseEngineResponse::set_allocated_error(::import_kvpb::Error* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.CloseEngineResponse.error)
}

// -------------------------------------------------------------------

// ImportEngineRequest

// bytes uuid = 1;
inline void ImportEngineRequest::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImportEngineRequest::uuid() const {
  // @@protoc_insertion_point(field_get:import_kvpb.ImportEngineRequest.uuid)
  return uuid_.GetNoArena();
}
inline void ImportEngineRequest::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.ImportEngineRequest.uuid)
}
#if LANG_CXX11
inline void ImportEngineRequest::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.ImportEngineRequest.uuid)
}
#endif
inline void ImportEngineRequest::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.ImportEngineRequest.uuid)
}
inline void ImportEngineRequest::set_uuid(const void* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.ImportEngineRequest.uuid)
}
inline ::std::string* ImportEngineRequest::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.ImportEngineRequest.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImportEngineRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:import_kvpb.ImportEngineRequest.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImportEngineRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.ImportEngineRequest.uuid)
}

// string pd_addr = 2;
inline void ImportEngineRequest::clear_pd_addr() {
  pd_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ImportEngineRequest::pd_addr() const {
  // @@protoc_insertion_point(field_get:import_kvpb.ImportEngineRequest.pd_addr)
  return pd_addr_.GetNoArena();
}
inline void ImportEngineRequest::set_pd_addr(const ::std::string& value) {
  
  pd_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.ImportEngineRequest.pd_addr)
}
#if LANG_CXX11
inline void ImportEngineRequest::set_pd_addr(::std::string&& value) {
  
  pd_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.ImportEngineRequest.pd_addr)
}
#endif
inline void ImportEngineRequest::set_pd_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pd_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.ImportEngineRequest.pd_addr)
}
inline void ImportEngineRequest::set_pd_addr(const char* value, size_t size) {
  
  pd_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.ImportEngineRequest.pd_addr)
}
inline ::std::string* ImportEngineRequest::mutable_pd_addr() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.ImportEngineRequest.pd_addr)
  return pd_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImportEngineRequest::release_pd_addr() {
  // @@protoc_insertion_point(field_release:import_kvpb.ImportEngineRequest.pd_addr)
  
  return pd_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImportEngineRequest::set_allocated_pd_addr(::std::string* pd_addr) {
  if (pd_addr != NULL) {
    
  } else {
    
  }
  pd_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pd_addr);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.ImportEngineRequest.pd_addr)
}

// -------------------------------------------------------------------

// ImportEngineResponse

// -------------------------------------------------------------------

// CleanupEngineRequest

// bytes uuid = 1;
inline void CleanupEngineRequest::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CleanupEngineRequest::uuid() const {
  // @@protoc_insertion_point(field_get:import_kvpb.CleanupEngineRequest.uuid)
  return uuid_.GetNoArena();
}
inline void CleanupEngineRequest::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.CleanupEngineRequest.uuid)
}
#if LANG_CXX11
inline void CleanupEngineRequest::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.CleanupEngineRequest.uuid)
}
#endif
inline void CleanupEngineRequest::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.CleanupEngineRequest.uuid)
}
inline void CleanupEngineRequest::set_uuid(const void* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.CleanupEngineRequest.uuid)
}
inline ::std::string* CleanupEngineRequest::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.CleanupEngineRequest.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CleanupEngineRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:import_kvpb.CleanupEngineRequest.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CleanupEngineRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.CleanupEngineRequest.uuid)
}

// -------------------------------------------------------------------

// CleanupEngineResponse

// -------------------------------------------------------------------

// CompactClusterRequest

// string pd_addr = 1;
inline void CompactClusterRequest::clear_pd_addr() {
  pd_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CompactClusterRequest::pd_addr() const {
  // @@protoc_insertion_point(field_get:import_kvpb.CompactClusterRequest.pd_addr)
  return pd_addr_.GetNoArena();
}
inline void CompactClusterRequest::set_pd_addr(const ::std::string& value) {
  
  pd_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.CompactClusterRequest.pd_addr)
}
#if LANG_CXX11
inline void CompactClusterRequest::set_pd_addr(::std::string&& value) {
  
  pd_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.CompactClusterRequest.pd_addr)
}
#endif
inline void CompactClusterRequest::set_pd_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pd_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.CompactClusterRequest.pd_addr)
}
inline void CompactClusterRequest::set_pd_addr(const char* value, size_t size) {
  
  pd_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.CompactClusterRequest.pd_addr)
}
inline ::std::string* CompactClusterRequest::mutable_pd_addr() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.CompactClusterRequest.pd_addr)
  return pd_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CompactClusterRequest::release_pd_addr() {
  // @@protoc_insertion_point(field_release:import_kvpb.CompactClusterRequest.pd_addr)
  
  return pd_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CompactClusterRequest::set_allocated_pd_addr(::std::string* pd_addr) {
  if (pd_addr != NULL) {
    
  } else {
    
  }
  pd_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pd_addr);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.CompactClusterRequest.pd_addr)
}

// .import_sstpb.CompactRequest request = 2;
inline bool CompactClusterRequest::has_request() const {
  return this != internal_default_instance() && request_ != NULL;
}
inline const ::import_sstpb::CompactRequest& CompactClusterRequest::_internal_request() const {
  return *request_;
}
inline const ::import_sstpb::CompactRequest& CompactClusterRequest::request() const {
  const ::import_sstpb::CompactRequest* p = request_;
  // @@protoc_insertion_point(field_get:import_kvpb.CompactClusterRequest.request)
  return p != NULL ? *p : *reinterpret_cast<const ::import_sstpb::CompactRequest*>(
      &::import_sstpb::_CompactRequest_default_instance_);
}
inline ::import_sstpb::CompactRequest* CompactClusterRequest::release_request() {
  // @@protoc_insertion_point(field_release:import_kvpb.CompactClusterRequest.request)
  
  ::import_sstpb::CompactRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline ::import_sstpb::CompactRequest* CompactClusterRequest::mutable_request() {
  
  if (request_ == NULL) {
    auto* p = CreateMaybeMessage<::import_sstpb::CompactRequest>(GetArenaNoVirtual());
    request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:import_kvpb.CompactClusterRequest.request)
  return request_;
}
inline void CompactClusterRequest::set_allocated_request(::import_sstpb::CompactRequest* request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(request_);
  }
  if (request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.CompactClusterRequest.request)
}

// -------------------------------------------------------------------

// CompactClusterResponse

// -------------------------------------------------------------------

// Error_EngineNotFound

// bytes uuid = 1;
inline void Error_EngineNotFound::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error_EngineNotFound::uuid() const {
  // @@protoc_insertion_point(field_get:import_kvpb.Error.EngineNotFound.uuid)
  return uuid_.GetNoArena();
}
inline void Error_EngineNotFound::set_uuid(const ::std::string& value) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:import_kvpb.Error.EngineNotFound.uuid)
}
#if LANG_CXX11
inline void Error_EngineNotFound::set_uuid(::std::string&& value) {
  
  uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:import_kvpb.Error.EngineNotFound.uuid)
}
#endif
inline void Error_EngineNotFound::set_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:import_kvpb.Error.EngineNotFound.uuid)
}
inline void Error_EngineNotFound::set_uuid(const void* value, size_t size) {
  
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:import_kvpb.Error.EngineNotFound.uuid)
}
inline ::std::string* Error_EngineNotFound::mutable_uuid() {
  
  // @@protoc_insertion_point(field_mutable:import_kvpb.Error.EngineNotFound.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error_EngineNotFound::release_uuid() {
  // @@protoc_insertion_point(field_release:import_kvpb.Error.EngineNotFound.uuid)
  
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error_EngineNotFound::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    
  } else {
    
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.Error.EngineNotFound.uuid)
}

// -------------------------------------------------------------------

// Error

// .import_kvpb.Error.EngineNotFound engine_not_found = 1;
inline bool Error::has_engine_not_found() const {
  return this != internal_default_instance() && engine_not_found_ != NULL;
}
inline void Error::clear_engine_not_found() {
  if (GetArenaNoVirtual() == NULL && engine_not_found_ != NULL) {
    delete engine_not_found_;
  }
  engine_not_found_ = NULL;
}
inline const ::import_kvpb::Error_EngineNotFound& Error::_internal_engine_not_found() const {
  return *engine_not_found_;
}
inline const ::import_kvpb::Error_EngineNotFound& Error::engine_not_found() const {
  const ::import_kvpb::Error_EngineNotFound* p = engine_not_found_;
  // @@protoc_insertion_point(field_get:import_kvpb.Error.engine_not_found)
  return p != NULL ? *p : *reinterpret_cast<const ::import_kvpb::Error_EngineNotFound*>(
      &::import_kvpb::_Error_EngineNotFound_default_instance_);
}
inline ::import_kvpb::Error_EngineNotFound* Error::release_engine_not_found() {
  // @@protoc_insertion_point(field_release:import_kvpb.Error.engine_not_found)
  
  ::import_kvpb::Error_EngineNotFound* temp = engine_not_found_;
  engine_not_found_ = NULL;
  return temp;
}
inline ::import_kvpb::Error_EngineNotFound* Error::mutable_engine_not_found() {
  
  if (engine_not_found_ == NULL) {
    auto* p = CreateMaybeMessage<::import_kvpb::Error_EngineNotFound>(GetArenaNoVirtual());
    engine_not_found_ = p;
  }
  // @@protoc_insertion_point(field_mutable:import_kvpb.Error.engine_not_found)
  return engine_not_found_;
}
inline void Error::set_allocated_engine_not_found(::import_kvpb::Error_EngineNotFound* engine_not_found) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete engine_not_found_;
  }
  if (engine_not_found) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      engine_not_found = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, engine_not_found, submessage_arena);
    }
    
  } else {
    
  }
  engine_not_found_ = engine_not_found;
  // @@protoc_insertion_point(field_set_allocated:import_kvpb.Error.engine_not_found)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace import_kvpb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::import_kvpb::Mutation_OP> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::import_kvpb::Mutation_OP>() {
  return ::import_kvpb::Mutation_OP_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_import_5fkvpb_2eproto
